1. # **Основы БД** {#основы-бд}

## **1.1. Что такое БД?** {#1.1.-что-такое-бд?}

База данных (БД) — это совокупность данных, хранящихся в упорядоченном виде, и механизмы управления этими данными. БД представляет собой организованную по определенным правилам структуру, которая хранит в себе данные и обеспечивает их целостность и безопасность. БД предназначена для хранения больших объемов информации, которая может быть легко обработана, добавлена, удалена или изменена.

## **1.2. Какие бывают БД?** {#1.2.-какие-бывают-бд?}

Базы данных бывают реляционными и нереляционными. Реляционные БД хранят данные в виде таблиц, а нереляционные — в виде документов, графов, ключей и значений. Пример реляционной БД: MySQL, PostgreSQL, Oracle, Microsoft SQL Server. Пример нереляционной БД: MongoDB, Redis, Neo4j, Cassandra.

## **1.3. Зачем нужны БД? Почему бы не хранить все в обычных файлах?** {#1.3.-зачем-нужны-бд?-почему-бы-не-хранить-все-в-обычных-файлах?}

Хранить данные в обычных файлах **можно**, но БД нужны, чтобы решать ключевые проблемы:

1. **Структура и поиск** — файлы требуют писать свой парсер, индексы, сортировки; БД делает это автоматически и быстро.
2. **Целостность данных** — ограничения, связи между таблицами, транзакции; файлы этого не дают.
3. **Многопользовательский доступ** — БД корректно управляет конкурентными изменениями, файлы легко ломаются при одновременном доступе.
4. **Масштабируемость** — большие объёмы данных, индексы, кэширование; файлы становятся медленными и тяжёлыми.
5. **Бэкапы и восстановление** — БД умеет делать точные снимки состояния и откаты, файлы приходится обрабатывать вручную.

Короче говоря, **БД превращает “кучу файлов” в управляемый, быстрый и безопасный сервис хранения данных**.

## **1.4. Что такое SQL?** {#1.4.-что-такое-sql?}

SQL (Structured Query Language) — декларативный язык структурированных запросов. Это язык программирования, который используется для создания, изменения и управления данными в реляционных базах данных.

## **1.5. Что такое реляционная БД?** {#1.5.-что-такое-реляционная-бд?}

Реляционная база данных — это база данных, основанная на реляционной модели данных.

Реляционная модель данных — это модель данных, в которой данные представлены в виде таблиц, состоящих из строк и столбцов. В реляционной модели каждая строка таблицы представляет собой запись, а столбец — атрибут, то есть, таблицы могут иметь relation (отношение) друг с другом.

Это достигается посредством указания внешнего ключа в таблице постов, который ссылается на таблицу пользователей. Внешние ключи не всегда используются, в угоду производительности, но они могут быть полезны для поддержания целостности данных. Таблица может просто хранить в себе номер пользователя, который создал пост, но внешний ключ позволяет убедиться, что пользователь с таким номером существует.

## **1.6. Что такое нереляционная БД?** {#1.6.-что-такое-нереляционная-бд?}

Нереляционная база данных — это база данных, основанная на нереляционной модели данных. Нереляционная модель данных — это модель данных, в которой данные представлены в виде документов, графов, ключей и значений. Нереляционные базы данных также называют NoSQL базами данных.

## **1.7. Что такое NoSQL?** {#1.7.-что-такое-nosql?}

NoSQL (Not Only SQL) — это подход к проектированию баз данных, в котором не используется реляционная модель данных. NoSQL базы данных используются для хранения и обработки больших объемов данных, которые не всегда имеют структурированный вид.

## **1.8. Какие бывают NoSQL базы данных?** {#1.8.-какие-бывают-nosql-базы-данных?}

NoSQL базы данных бывают четырех типов:

- Ключ-значение (key-value) базы данных. Пример: Redis, Memcached.
- Документоориентированные (document-oriented) базы данных. Пример: MongoDB, CouchDB.
- Семейство столбцов (column family) базы данных. Пример: Cassandra, HBase.
- Графовые (graph) базы данных. Пример: Neo4j, OrientDB.

## **1.9. Как компьютер хранит информацию? Какая разница между ОЗУ и персистентным хранилищем?** {#1.9.-как-компьютер-хранит-информацию?-какая-разница-между-озу-и-персистентным-хранилищем?}

Память компьютера организована в несколько уровней:

1. **Регистры CPU** — самый быстрый, но ограниченный по объему уровень (несколько десятков байт).
2. **Кэш-память (Cache)** — промежуточное хранилище между процессором и оперативной памятью.
3. **Оперативная память (RAM)** — медленнее кэша, но быстрее постоянного хранилища (SSD/HDD).
4. **Постоянное хранилище (SSD/HDD)** — для долговременного хранения данных.

Персистентное хранилище (persistent storage) в контексте ПК — это тип памяти или устройства, в котором данные **сохраняются постоянно**, даже когда компьютер выключен.

В отличие от оперативной памяти (RAM), которая теряет данные после выключения питания, персистентное хранилище сохраняет информацию длительно.

Примеры персистентного хранилища:

- **Жесткий диск (HDD)**
- **Твердотельный накопитель (SSD)**
- **Флеш-накопители (USB, SD-карты)**
- **Оптические диски (CD, DVD, Blu-ray)**

Основные характеристики:

1. **Сохранение данных при выключении питания** — ключевое отличие от RAM.
2. **Большая емкость** — обычно в сотнях гигабайт и терабайт.
3. **Медленнее, чем RAM** — доступ к данным занимает больше времени.

# 2 Свойства, принципы работы БД {#2-свойства,-принципы-работы-бд}

## **2.1. Что такое ACID?** {#2.1.-что-такое-acid?}

ACID — это аббревиатура, которая означает Atomicity, Consistency, Isolation, Durability (Атомарность, Согласованность, Изолированность, Долговечность). Это свойства транзакций в реляционных базах данных.

- Атомарность (Atomicity) — это свойство транзакции, которое гарантирует, что либо все операции транзакции будут выполнены, либо ни одна.
- Согласованность (Consistency) — это свойство транзакции, которое гарантирует, что транзакция не нарушает целостность данных.
- Изолированность (Isolation) — это свойство транзакции, которое гарантирует, что транзакция не будет видна другим транзакциям, пока она не будет завершена.
- Долговечность (Durability) — это свойство транзакции, которое гарантирует, что результаты транзакции будут сохранены после ее завершения

## **2.2. Что такое CAP?** {#2.2.-что-такое-cap?}

CAP — это аббревиатура, которая означает Consistency, Availability, Partition tolerance (Согласованность, Доступность, Устойчивость к разделению). Это свойства распределенных систем.

- Согласованность (Consistency) — это свойство распределенной системы, которое гарантирует, что каждый узел системы видит одни и те же данные одновременно.
- Доступность (Availability) — это свойство распределенной системы, которое гарантирует, что каждый запрос к системе будет завершен успешно.
- Устойчивость к разделению (Partition tolerance) — это свойство распределенной системы, которое гарантирует, что система будет работать даже в случае разделения сети на части.

## **2.3 Что такое транзакция?** {#2.3-что-такое-транзакция?}

Транзакция — это набор операций, которые выполняются как единое целое. Транзакции используются для обеспечения целостности данных в реляционных базах данных.

## **2.4 Паттерны транзакций** {#2.4-паттерны-транзакций}

Существует несколько паттернов транзакций, которые описывают распространенные способы использования и управления транзакциями. Вот некоторые из них:

1. **Транзакция с сохранной точкой (Savepoint Transaction)**  
   Используется, когда внутри одной транзакции есть несколько шагов, и не все из них критичны.  
   Мы можем поставить savepoint и при ошибке откатиться только до него, не отменяя всю работу. Это особенно полезно, когда транзакция длинная и не хочется терять всё прогресс.

2. **Gather-insert Transaction**  
    Это паттерн для сценариев высокой конкуренции на вставку.  
   Вместо того чтобы держать блокировки на одной таблице и ловить конфликты, данные сначала пишутся в буферные (временные) таблицы. Потом в транзакции они объединяются.  
   За счёт этого снижается уровень блокировок и улучшается масштабируемость.
3. **Пессимистическая блокировка (Pessimistic Locking)**  
   Классический вариант, когда мы сразу ставим блокировку на строку или ресурс.  
   Хорошо работает, когда вероятность конфликта высокая и цена отката велика.  
   Но у такого подхода есть минус — блокировки могут держаться долго, создавая задержки для других транзакций.
4. **Оптимистическая блокировка (Optimistic Locking)**  
   Противоположный подход: блокировок нет, вместо этого используется версионирование (например, поле `version` или timestamp).  
   Перед записью проверяем, не изменились ли данные. Если изменились — транзакцию нужно повторить.  
   Отлично подходит для сценариев, где конфликты редки, а нагрузка высокая.

5. **Распределенная транзакция (Distributed Transaction)**  
   Здесь речь про работу с несколькими источниками данных или сервисами. Обычно применяется протокол двухфазного коммита **(2PC) или саги**. Это сложная история, потому что растет латентность и появляется много точек отказа..

6. **Компенсирующая транзакция (Compensating Transaction)**  
   Часто используется в распределенных системах вместо жёсткого ACID. Если один из шагов в цепочке не удался, то мы не делаем откат, а выполняем “обратную” транзакцию, которая логически компенсирует ошибку. Это как раз основа паттерна **Saga** в микросервисах.

## **2.5 Что такое 2pc** {#2.5-что-такое-2pc}

**Two-Phase Commit (2PC)**  
 Это классический протокол для распределённых транзакций. Его задача — гарантировать атомарность, когда одна транзакция затрагивает несколько ресурсов (например, базы данных на разных серверах).  
 Механизм работает в два шага:

1. **Prepare (фаза голосования):** координатор рассылает запрос всем участникам: “Можешь ли ты зафиксировать транзакцию?”. Каждый участник резервирует ресурсы и отвечает “готов” или “отмена”.

2. **Commit/Rollback (фаза фиксации):** если все ответили “готов” — координатор посылает “commit”. Если хоть один сказал “отмена” — всем рассылается “rollback”.

**Плюсы:** гарантирует согласованность.  
**Минусы:** синхронность и блокировки → участники ждут решения координатора, возможна ситуация “зависшей транзакции” при сбое. Поэтому 2PC плохо масштабируется и редко используется в микросервисах в чистом виде.

## **2.6 Что такое saga** {#2.6-что-такое-saga}

**Saga**  
 Это более современный паттерн для распределённых систем, в частности для микросервисов. В отличие от 2PC, саги не делают жёсткий глобальный commit/rollback, а строятся как последовательность локальных транзакций, каждая из которых выполняется в своём сервисе.

- Если все шаги успешны — считаем, что вся сага прошла успешно.

- Если один из шагов падает — запускаются **компенсирующие транзакции** для отката предыдущих шагов.

**Реализация бывает двух видов:**

- **Хореография (choreography):** шаги саги запускаются событиями. Один сервис завершил транзакцию → публикует событие → следующий сервис реагирует.

- **Оркестрация (orchestration):** есть центральный “оркестратор”, который управляет выполнением шагов и вызывает нужные сервисы.

**Плюсы:** асинхронность, отказоустойчивость, подходит для микросервисов.  
 **Минусы:** сложнее в реализации, нужны компенсирующие транзакции и продуманная архитектура (особенно в хореографии может получиться “messy event hell”).

##

## **2.7 Когда использовать 2pc а когда saga** {#2.7-когда-использовать-2pc-а-когда-saga}

Используем **2PC**, когда:

- критична строгая атомарность (ACID),
- ресурсов немного и они под нашим полным контролем,
- допустимы блокировки и задержки (например, внутри одного кластера БД).

Используем **Saga**, когда:

- система распределённая (микросервисы),
- нужна масштабируемость и отказоустойчивость,
- можем жить с eventual consistency и реализовать компенсирующие транзакции.

**Реальный кейс как пример:**

- **Сервис A (Задачи)** → хранит и выдаёт пользователю задания.
- **Сервис B (Ответы)** → хранит правильные ответы.
- У каждого своя база.

Теперь допустим, у нас есть операция:  
 “**Создать новую задачу вместе с правильным ответом**”.  
 Тут задействованы **оба сервиса** → получается распределённая транзакция.

**Пример сценария (хореография)**

1. Сервис A (Задачи) создаёт задачу → публикует событие `TaskCreated`.
2. Сервис B (Ответы) подписан на `TaskCreated` → создаёт правильный ответ → публикует событие `AnswerCreated`.
3. Если создание ответа упало → сервис B публикует событие `AnswerCreationFailed`.
4. Сервис A подписан на `AnswerCreationFailed` → выполняет компенсирующую транзакцию (удаляет задачу).

Плюсы хореографии

- Нет централизованного компонента → меньше узких мест.
- Сервисы более независимые.
- Хорошо масштабируется при большом количестве микросервисов.

🔹 Минусы

- Сложнее отлаживать → события могут приходить в разном поряде.
- Нужно аккуратно продумывать все компенсации.
- Возможны ситуации “messy event hell”, если много шагов и много сервисов.

“**Messy Event Hell**” — это неофициальный термин, который описывает хаос, возникающий в системах, построенных на **событиях**, особенно в хореографических сагaх.

**Пример сценария (оркестратор):**

1. Сервис A → “создать задачу” (локальная транзакция в его БД).
2. Сервис B → “создать правильный ответ” (локальная транзакция в его БД).
3. Если шаг 2 упал → оркестратор вызывает у сервиса A операцию “откатить задачу” (например, удалить созданную задачу).

| ![][image1] | Каждый сервис сам отвечает за свою БД (никаких общих транзакций). У каждого сервиса есть API для компенсации (например, `DELETE /tasks/:id` или `DELETE /answers/:id`). Оркестратор (может быть отдельным сервисом или даже одна функция в Go) выполняет шаги один за другим и вызывает компенсации при ошибке. |
| :---------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![][image2] | В итоге у тебя нет строгой атомарности, как в 2PC, но система приходит к консистентному состоянию: либо задача и ответ оба есть, либо оба удалены.                                                                                                                                                              |

## **2.8. Подходы к управлению транзакциями** {#2.8.-подходы-к-управлению-транзакциями}

**1\. Локальные транзакции**  
**(Local Transactions)**

- **Описание:** применяются к одной базе данных или ресурсу. Всё происходит внутри одной СУБД, и транзакции управляются средствами самой базы.
- **Пример:** обычные SQL-транзакции (`BEGIN`, `COMMIT`, `ROLLBACK`) внутри Postgres или MySQL.

**Когда использовать:** если система монолитная и весь функционал ограничен одной базой — это самый простой и безопасный вариант.

**2\. Распределенные транзакции**  
**(Distributed Transactions)**

- **Описание:** затрагивают несколько баз данных или ресурсов, часто на разных серверах. Применяются протоколы вроде **2PC**, чтобы обеспечить атомарность.
- **Пример:** перевод денег между счетами в разных банках, где каждая база должна согласованно обновить свои данные.

**Когда использовать:** критически важно соблюсти **ACID** на нескольких ресурсах, но протоколы тяжёлые, блокировки могут тормозить систему.

В микросервисах 2PC используют редко.

**3\. Управление транзакциями на уровне приложения**  
**(Application-Level Transaction Management)**

- **Описание:** приложение самостоятельно начинает, фиксирует и откатывает транзакции через API СУБД или сервисов.
- **Пример:** в Go через `db.Begin()` → `tx.Commit()` / `tx.Rollback()`.

**Когда использовать:** если нужна гибкость и контроль над поведением транзакции в коде, например для комбинирования нескольких шагов внутри одного сервиса.

**4\. Управление транзакциями на уровне объекта**  
**(Object-Level Transaction Management)**

- **Описание:** транзакции управляются на уровне объектов или моделей данных. Каждый объект может иметь свою транзакцию, возможны вложенные транзакции.
- **Пример:** ORM с поддержкой транзакций (GORM, Hibernate), где можно оборачивать операции с объектами в транзакцию.

**Когда использовать:** удобно при работе с объектно-ориентированными системами или при сложной бизнес-логике, где разные объекты должны обновляться атомарно.

**5\. Управление транзакциями на уровне сообщений**  
**(Message-Level Transaction Management)**

- **Описание:** транзакции управляются через сообщения в асинхронных системах. Каждое сообщение может быть частью транзакции, поддерживаются атомарные операции с очередью.
- **Пример:** Kafka или RabbitMQ с транзакциями, когда публикация и обработка сообщений должны быть согласованы с изменениями данных.

**Когда использовать:** в распределённых или event-driven системах, когда нет возможности или желания держать глобальные блокировки, а важна согласованность через события.

**Итог:**  
 Выбор подхода зависит от архитектуры:

- **Монолит, одна БД** → локальные транзакции.
- **Микросервисы, распределённые ресурсы** → saga или message-level транзакции.
- **Классическая банковская система** → можно 2PC, но с оглядкой на блокировки и отказоустойчивость.

## **2.9. Уровни изоляции транзакций** {#2.9.-уровни-изоляции-транзакций}

**Уровни изоляции транзакций** определяют, какие изменения данных видны другим транзакциям во время выполнения текущей транзакции.

**Read Uncommitted (Чтение неподтвержденных данных)**  
 Транзакция может видеть **неподтвержденные изменения**, внесённые другими транзакциями. Возможны “грязные” чтения.

**Read Committed (Чтение подтвержденных данных)**  
 Транзакция видит только **подтвержденные изменения** других транзакций. Грязные чтения исключены, но возможны неповторяемые чтения (non-repeatable reads).

**Repeatable Read (Повторяемое чтение)**  
 Транзакция **гарантированно видит одни и те же данные при повторном чтении** в рамках своей транзакции. Возможны фантомные записи (новые строки, вставленные другими транзакциями, могут появиться).

**Serializable (Сериализуемость)**  
 Транзакции выполняются так, как будто они **выполняются последовательно**. Исключены грязные чтения, неповторяемые чтения и фантомные записи.

**Snapshot (Снимок, характерен для PostgreSQL и некоторых СУБД)**  
 Транзакция работает с **снимком данных на момент её начала**. Все изменения, внесённые другими транзакциями после начала, не видны. Поведение похоже на Repeatable Read, но с гарантией изоляции через версионирование данных (MVCC).

\*Неповторяемое чтение (Non-Repeatable Read) транзакция читает одни и те же строки дважды, и между этими чтениями другая транзакция изменила эти данные.

\*Грязное чтение (Dirty Read) транзакция читает данные, которые были изменены другой транзакцией, но ещё не подтверждены (не committed).

## **2.10. Что такое in-memory хранилище? Какие есть решения? Зачем они нужны?** {#2.10.-что-такое-in-memory-хранилище?-какие-есть-решения?-зачем-они-нужны?}

**In-memory хранилище (In-memory storage)**

- **Определение:** Хранение данных в оперативной памяти (RAM) вместо HDD/SSD.
- **Главное преимущество:** Очень быстрый доступ к данным → высокая производительность и низкая задержка.

**Популярные решения:**

- **Redis:** Кэш, очередь сообщений, in-memory база данных. Поддерживает строки, списки, множества, хэши.
- **Memcached:** Простой кэш данных в памяти для ускорения доступа (HTML, изображения).
- **Apache Cassandra:** Распределённая база данных, использует RAM для кэша, высокая доступность и масштабируемость.
- **VoltDB:** Реляционная in-memory база для транзакций в реальном времени.
- **Hazelcast:** Распределённое in-memory хранилище, кэширование и распределённые вычисления.

**Зачем нужны:**

1. **Высокая производительность** – чтение/запись быстрее диска.
2. **Снижение задержки** – критично для финансовых приложений, игр, real-time систем.
3. **Масштабируемость** – легко масштабируются горизонтально.

## **2.11. Какие есть подходы к масштабированию?** {#2.11.-какие-есть-подходы-к-масштабированию?}

Масштабирование — это способ повысить производительность и устойчивость системы при росте нагрузки.

**Вертикальное масштабирование (Vertical scaling)**

- Увеличение мощности одного сервера: больше CPU, RAM, диска.
- Просто в реализации, но ограничено пределами «железа» и дорого при больших масштабах.

**Горизонтальное масштабирование (Horizontal scaling)**

- Добавление новых серверов/инстансов в кластер.
- Позволяет распределять нагрузку и повышать отказоустойчивость.
- Основной подход в современных высоконагруженных системах.

**Облачное масштабирование (Cloud scaling)**

- Автоматическое увеличение/уменьшение ресурсов (auto-scaling) в AWS, GCP, Azure.
- Удобно для переменной нагрузки (например, пики в e-commerce).

**Микросервисы**

- Разделение системы на независимые сервисы.
- Масштабируем только «узкие места», а не всё приложение целиком.
- Легче внедрять гибкое горизонтальное масштабирование.

**Балансировка нагрузки (Load balancing)**

- Равномерное распределение запросов между инстансами.
- Увеличивает производительность и даёт отказоустойчивость.

**Кэширование (Caching)**

- Снижение нагрузки на БД и сервисы за счёт сохранения часто используемых данных.
- Используется на разных уровнях: CDN, Redis/Memcached, кэш на уровне приложения.

**Шардинг (Sharding)**

- Разделение данных на сегменты (шарды) и хранение их на разных серверах.
- Позволяет работать с огромными объёмами данных.

**Оптимизация кода и запросов**

- Перед масштабированием железа часто стоит оптимизировать приложение: пересмотреть SQL-запросы, убрать «бутылочные горлышки».
- Иногда грамотная оптимизация даёт больший прирост, чем добавление серверов.

## **2.12. Что такое шардинг и репликация?** {#2.12.-что-такое-шардинг-и-репликация?}

**Шардинг (Sharding)**

Шардинг — это метод **горизонтального масштабирования**, когда данные делятся на независимые сегменты (**шарды**) и распределяются по разным серверам.

- Каждый шард хранит только часть данных и обрабатывает только свою нагрузку.
- Это позволяет системе обрабатывать большие объемы данных и писать/читать параллельно.

Минусы: Трудности с глобальными запросами (`JOIN` или агрегации по всем шардам).

**Репликация (Replication)**

Репликация — это **создание копий данных** на нескольких серверах.

- Обычно есть **primary** (мастер) и несколько **replica** (слейвов).
- Primary принимает записи, реплики синхронно или асинхронно копируют изменения и обслуживают запросы на чтение.

Минусы: Задержка репликации (особенно в асинхронных схемах).

**Шардинг и репликация используют вместе**:

- Шардинг — для горизонтального масштабирования (делим данные на сегменты).
- Репликация — для отказоустойчивости и масштабирования чтения.

**Пример:**

- Пользователи делятся по регионам → каждый регион хранится в отдельном шарде.
- В каждом шарде — одна основная база \+ несколько реплик для чтения и резервирования.

## **2.13. Какие типы репликации существуют в PostgreSQL?** {#2.13.-какие-типы-репликации-существуют-в-postgresql?}

1\. Физическая (Streaming Replication, Master-Slave)

- **Классический вариант:** есть один **primary** (мастер) и несколько **standby** (реплик).
- Реплики получают WAL-записи (журнал транзакций) и применяют их для синхронизации.
- Реплики доступны только для **чтения**.

**Плюсы:** высокая производительность, простая настройка.  
 **Минусы:** нагрузку на запись нельзя распределить.

2\. Логическая репликация (Logical Replication)

- Позволяет реплицировать **не всю БД, а выбранные таблицы/колонки**.
- Работает на уровне изменений данных (INSERT, UPDATE, DELETE).
- Подходит для интеграции, аналитики, миграций и построения event-driven систем.

**Плюсы:** гибкость (можно фильтровать данные).  
**Минусы:** медленнее физической, больше накладных расходов.

3\. Мастер-мастер репликация (Multi-Master, Bi-Directional Replication, BDR)

- Несколько узлов работают как мастера: принимают и записи, и чтение.
- Узлы синхронизируются между собой (обычно через логическую репликацию).
- Используется для географически распределённых систем.

**Плюсы:** распределение нагрузки на запись.  
 **Минусы:** сложная настройка, конфликты при синхронизации.

4\. Каскадная репликация (Cascading Replication)

- Реплика может сама быть источником для других реплик.
- Полезно, когда у вас десятки узлов, и не хочется перегружать мастер.

5\. Асинхронная vs. Синхронная

- **Асинхронная (по умолчанию):** мастер не ждёт подтверждения от реплик → быстрее, но возможна потеря данных при падении мастера.
- **Синхронная:** мастер ждёт подтверждения от хотя бы одной реплики → данные гарантированно не теряются, но выше задержки записи.

## **2.14. По какому принципу могут данные шардироваться?** {#2.14.-по-какому-принципу-могут-данные-шардироваться?}

**1\. Горизонтальное шардирование (Horizontal Sharding)**

- Данные делятся по **строкам**.
- Каждая таблица в шарде содержит одинаковую схему, но разные подмножества строк.

Пример: пользователи из Европы в одном шарде, из Азии — в другом.  
 ❌ Минусы: сложность при глобальных запросах (JOIN по всем шардам).

**2\. Вертикальное шардирование (Vertical Sharding)**

- Таблица разбивается по **столбцам**.
- Каждый шард хранит только часть атрибутов объекта.

Пример: в одном шарде — «основные данные пользователя» (id, name, email), в другом — «редко используемые данные» (preferences, logs).  
 ❌ Минусы: чаще нужны JOIN между шардами.

**3\. Диапазонное шардирование (Range Sharding)**

- Деление по диапазону значений ключа.

Пример: даты заказов → `2020–2021` в одном шарде, `2022–2023` в другом.  
 ❌ Минусы: при «горячем диапазоне» один шард может перегружаться.

**4\. Хэш-шардирование (Hash Sharding)**

- Используется хэш-функция для ключа (например, `user_id % N`).

Пример: если у нас 4 шарда, пользователь с id=123 попадёт в шард `123 % 4 = 3`.  
 ❌ Минусы: сложно делать range-запросы.

**5\. По типу (Type Sharding)**

- Данные делятся по сущностям или категориям.

Пример: одни шарды для пользователей, другие — для продуктов, третьи — для логов.  
 ❌ Минусы: возможны перекосы нагрузки (например, «шард пользователей» перегружен).

**6\. Смешанное (Composite Sharding)**

- Комбинация методов.

# 3 SQL и операции с данными {#3-sql-и-операции-с-данными}

## **3.1. Что такое SQL?** {#3.1.-что-такое-sql?}

SQL (Structured Query Language) \--- декларативный язык структурированных запросов. Это язык программирования, который используется для создания, изменения и управления данными в реляционных базах данных.

## **3.2. Синтаксис языка SQL, Что такое DDL, DML, TCL, DCL?** {#3.2.-синтаксис-языка-sql,-что-такое-ddl,-dml,-tcl,-dcl?}

Вот основные элементы синтаксиса SQL и практические навыки, связанные с ним:

1. Операторы DDL  
   (Data Definition Language \- Язык Определения Данных):

   - CREATE TABLE: Создание новой таблицы.
   - ALTER TABLE: Изменение структуры существующей таблицы.
   - DROP TABLE: Удаление таблицы.
   - CREATE DATABASE: Создание новой базы данных.
   - ALTER DATABASE: Изменение базы данных.
   - DROP DATABASE: Удаление базы данных.

2. Операторы DML  
   (Data Manipulation Language \- Язык Манипуляции Данными)

   - SELECT: Извлечение данных из таблицы.
   - INSERT: Вставка новых данных в таблицу.
   - UPDATE: Обновление существующих данных в таблице.
   - DELETE: Удаление данных из таблицы.

3. Операторы DCL  
   (Data Control Language \- Язык Контроля Доступа к Данным):

   - GRANT: Предоставление прав доступа к данным другим пользователям  
      или ролям.
   - REVOKE: Отзыв прав доступа к данным.

4. Операторы TCL  
   (Transaction Control Language \- Язык Управления Транзакциями):

   - COMMIT: Завершение текущей транзакции и сохранение изменений в базе данных.
   - ROLLBACK: Откат текущей транзакции и отмена всех изменений.
   - SAVEPOINT: Создание точки сохранения внутри транзакции.

5. Операторы фильтрации и сортировки:

   - WHERE: Фильтрация результатов запроса на основе условий.
   - ORDER BY: Сортировка результатов по одному или нескольким столбцам.
   - GROUP BY: Группировка данных по одному или нескольким столбцам.
   - HAVING: Фильтрация результатов группировки.

6. Функции агрегации:

   - COUNT(): Подсчет количества строк.
   - SUM(): Суммирование числовых значений.
   - AVG(): Вычисление среднего значения.
   - MAX(): Поиск максимального значения.
   - MIN(): Поиск минимального значения.

7. Соединения таблиц:

   - INNER JOIN: Внутреннее соединение двух таблиц на основе совпадающих значений.
   - LEFT JOIN: Левое соединение, включая все строки из первой таблицы и соответствующие строки из второй таблицы.
   - RIGHT JOIN: Правое соединение, включая все строки из второй таблицы и соответствующие строки из первой таблицы.
   - FULL OUTER JOIN: Полное внешнее соединение, включая все строки из обеих таблиц.

8. Подзапросы:
   - Вложенные SELECT запросы, используемые для выполнения запросов внутри других запросов.

## **3.3. Нюансы работы с NULL в SQL. Как проверить поле на NULL?** {#3.3.-нюансы-работы-с-null-в-sql.-как-проверить-поле-на-null?}

`NULL` в SQL — это **не значение**, а **отсутствие значения** (неопределённость).  
Поэтому он ведёт себя особым образом в выражениях, сравнениях и агрегациях.

**Проверка на `NULL:`** `SELECT * FROM users WHERE email IS NULL;`  
найдём записи без e-mail.

**Проверка на "не `NULL`":** `SELECT * FROM users WHERE email IS NOT NULL;`

**Замена `NULL` на дефолт:** `SELECT COALESCE(email, 'no-email') FROM users;`  
если `email` \= NULL, вернётся `'no-email'`.

**1\. Сравнения с `NULL.`**

Нельзя писать `= NULL` или `!= NULL`.  
`WHERE email = NULL   -- ❌ всегда вернёт UNKNOWN`  
`WHERE email IS NULL  -- ✅ правильный вариант`

**2\. Три-значная логика (TRUE / FALSE / UNKNOWN)**

Если в выражении участвует `NULL`, результат часто становится `UNKNOWN`.  
`SELECT 1 WHERE NULL = 5;   -- ничего не вернёт`

**3\. `NULL` в агрегации**

`COUNT(*)` считает все строки, даже с `NULL`.  
`COUNT(column)` игнорирует `NULL`.

`COUNT(email)   -- посчитает только строки, где email NOT NULL`  
`COUNT(*)       -- посчитает все строки`

**4\. `NULL` в `JOIN`**

При `INNER JOIN` строки с `NULL` в ключах не соединяются.  
При `LEFT JOIN` в результирующей таблице могут появиться `NULL`\-ы в полях правой таблицы.

**5\. `NULL` в `GROUP BY.`** Все `NULL` значения попадают в **одну группу**.

## **3.4. Виды Join'ов?** {#3.4.-виды-join'ов?}

**1\. INNER JOIN**

Возвращает только строки, у которых есть совпадения в обеих таблицах.

`SELECT u.id, u.name, o.id AS order_id`  
`FROM users u`  
`INNER JOIN orders o ON u.id = o.user_id;`

**2\. LEFT JOIN (LEFT OUTER JOIN)**

Берёт все строки из левой таблицы \+ совпадающие строки из правой. Если совпадений нет → `NULL`.

`SELECT u.id, u.name, o.id AS order_id`  
`FROM users u`  
`LEFT JOIN orders o ON u.id = o.user_id;`

**3\. RIGHT JOIN (RIGHT OUTER JOIN)**

Аналог `LEFT JOIN`, но берёт все строки из **правой таблицы**.

На практике почти не используется, т.к. всегда можно переписать через `LEFT JOIN`.

**4\. FULL JOIN (FULL OUTER JOIN)**

Возвращает все строки из обеих таблиц. Если совпадений нет, подставляются `NULL`.

`SELECT u.id, o.id`  
`FROM users u`  
`FULL JOIN orders o ON u.id = o.user_id;`

**5\. CROSS JOIN**

Декартово произведение: каждая строка первой таблицы × каждая строка второй.

`SELECT u.id, p.id`  
`FROM users u`  
`CROSS JOIN products p;`

## **3.5. Что лучше использовать join или подзапросы?** {#3.5.-что-лучше-использовать-join-или-подзапросы?}

**JOIN:**

- Обычно **быстрее**, т.к. оптимизатор может использовать индексы и строить эффективные планы выполнения.
- Удобен для **объединения данных** из нескольких таблиц.
- Хорошо читается, если нужно просто соединить таблицы по ключам.

**Подзапросы:**

- Удобны для **агрегаций** и случаев, когда нужно сначала «посчитать что-то», а потом использовать это в фильтре.
- Иногда делают SQL **более читаемым** (например, при фильтрации по сложным условиям).
- Могут быть **медленнее**, если оптимизатор не умеет «разворачивать» подзапрос в `JOIN`.

Для объединения таблиц **почти всегда лучше `JOIN`** (особенно при больших данных и наличии индексов).

Подзапросы хороши, когда:

- нужно сначала агрегировать / выбрать топ-N
- нужна вложенная фильтрация
- читаемость выше, чем с `JOIN`

## **3.6. Чем WHERE отличается от HAVING?** {#3.6.-чем-where-отличается-от-having?}

**WHERE**

- Фильтрует **строки до группировки и агрегации**.
- Применяется к обычным столбцам.
- Нельзя использовать агрегатные функции (`SUM`, `COUNT`, `AVG` и т. д.).

**Пример:** выбрать только пользователей старше 18 лет:

`SELECT *`  
`FROM users`  
`WHERE age >= 18;`

**HAVING**

- Фильтрует **группы после группировки и агрегации**.
- Применяется к результатам `GROUP BY` или агрегатам.
- Часто идёт вместе с `GROUP BY`.

**Пример:** выбрать только те страны, где больше 100 пользователей:

`SELECT country, COUNT(*) AS user_count`  
`FROM users`  
`GROUP BY country`  
`HAVING COUNT(*) > 100;`

**Разница в одном примере**

Найти всех пользователей старше 18 лет и показать только те города, где больше 10 таких пользователей:

`SELECT city, COUNT(*) AS cnt`  
`FROM users`  
`WHERE age >= 18        -- фильтруем строки до агрегации`  
`GROUP BY city`  
`HAVING COUNT(*) > 10;  -- фильтруем уже сгруппированные данные`

**Запомни простую формулу для собеса**

- `WHERE` → фильтруем **строки** (до `GROUP BY`).
- `HAVING` → фильтруем **группы** (после `GROUP BY`).

## **3.7. Что такое ORDER BY?** {#3.7.-что-такое-order-by?}

`ORDER BY` используется для сортировки результата запроса по одному или нескольким столбцам. Сортировка может быть по возрастанию (`ASC`) или по убыванию (`DESC`). Это базовый инструмент для контроля порядка выдачи данных, особенно когда результаты нужно выводить пользователю или передавать в отчёт.

Пример:

`SELECT *`  
`FROM employees`  
`ORDER BY last_name ASC;`

## **3.8. Что такое GROUP BY?** {#3.8.-что-такое-group-by?}

`GROUP BY` группирует строки по значениям одного или нескольких столбцов, что позволяет применять агрегирующие функции (`SUM`, `COUNT`, `AVG` и др.) к каждой группе отдельно. Используется, когда нужно свести данные к более компактному виду или посчитать агрегаты по категориям.

Пример:

`SELECT department, COUNT(*)`  
`FROM employees`  
`GROUP BY department;`

## **3.9. Что такое DISTINCT?** {#3.9.-что-такое-distinct?}

`DISTINCT` удаляет дублирующиеся строки из результата запроса. Часто используется, когда необходимо получить список уникальных значений одного или нескольких столбцов. Важно понимать, что `DISTINCT` применяется ко всем выбранным столбцам вместе, а не по отдельности.

Пример:

`SELECT DISTINCT department`  
`FROM employees;`

## **3.10. Что такое LIMIT?** {#3.10.-что-такое-limit?}

`LIMIT` ограничивает количество возвращаемых строк. Полезен для пагинации или когда нужно получить лишь часть данных (например, топ N записей). Работает в большинстве SQL-систем, но синтаксис может немного различаться.

Пример:

`SELECT *`  
`FROM products`  
`LIMIT 10;`

## **3.11. Что такое EXISTS?** {#3.11.-что-такое-exists?}

`EXISTS` проверяет, существует ли хотя бы одна строка, удовлетворяющая условию подзапроса. Возвращает `TRUE`, если подзапрос возвращает хотя бы одну строку, и `FALSE` — если нет. Это эффективный способ фильтровать данные, когда нас интересует не конкретное значение, а факт существования записи.

Пример:

`SELECT employee_name`  
`FROM employees`  
`WHERE EXISTS (`  
 `SELECT 1`  
 `FROM orders`  
 `WHERE orders.employee_id = employees.employee_id`  
`);`

## **3.12. Расскажите про оператор IN,** {#3.12.-расскажите-про-оператор-in,}

**IN**  
 `IN` используется для проверки, содержится ли значение столбца в заданном множестве значений или результатах подзапроса. Это удобная альтернатива множественным `OR`\-условиям и помогает сделать запрос более читаемым и оптимизированным.

Пример:

`SELECT *`  
`FROM products`  
`WHERE category_id IN (1, 2, 3);`

В реальных кейсах часто используется для фильтрации по списку статусов, категорий или ID, когда заранее известен набор значений.

## **3.13. Расскажите про оператор BETWEEN,** {#3.13.-расскажите-про-оператор-between,}

**BETWEEN**  
 `BETWEEN` проверяет, находится ли значение столбца в определённом диапазоне, включительно. Чаще всего применяется для числовых, денежных или датовых полей.

Пример:

`SELECT *`  
`FROM sales`  
`WHERE sale_amount BETWEEN 1000 AND 5000;`

Важно помнить, что `BETWEEN a AND b` включает границы `a` и `b`. На практике это удобно для выборки за период времени или по диапазону сумм.

**3.14. Расскажите про оператор LIKE.**

**LIKE**  
 `LIKE` используется для поиска строк, соответствующих определённому шаблону. Позволяет использовать символы подстановки:

- `%` — любое количество символов, включая ноль
- `_` — ровно один символ

Пример:

`SELECT *`  
`FROM customers`  
`WHERE last_name LIKE 'Smith%';`

На практике `LIKE` полезен для поиска по частям строк: например, поиск клиентов по первой букве фамилии или товара по части названия. Для больших таблиц стоит учитывать производительность и при необходимости использовать полнотекстовый поиск или индексы.

## **3.15. Что делает оператор MERGE? Какие у него есть ограничения?** {#3.15.-что-делает-оператор-merge?-какие-у-него-есть-ограничения?}

**MERGE**

`MERGE` (часто называют UPSERT или `ON DUPLICATE KEY UPDATE` в некоторых СУБД) позволяет выполнить **вставку или обновление записи** в таблице в зависимости от того, существует ли она уже. Это объединяет логику `INSERT` и `UPDATE` в одном операторе, что упрощает работу с дубликатами и синхронизацией данных.

**Принцип работы:**

1. **INSERT** — если запись с заданным ключом отсутствует, создаётся новая.
2. **UPDATE** — если запись с ключом уже существует, она обновляется новыми значениями.

Пример (синтаксис для SQL Server / Oracle):

`MERGE INTO employees AS target`  
`USING (SELECT 1 AS employee_id, 'John Doe' AS name) AS source`  
`ON target.employee_id = source.employee_id`  
`WHEN MATCHED THEN`  
 `UPDATE SET name = source.name`  
`WHEN NOT MATCHED THEN`  
 `INSERT (employee_id, name) VALUES (source.employee_id, source.name);`

**Практическое использование:**

- Синхронизация данных между таблицами или источниками.
- Упрощение обработки «добавить или обновить».
- Эффективная работа с ETL и массовыми обновлениями данных.

**Ограничения и нюансы:**

1. **Не является стандартным SQL** — синтаксис и поддержка зависят от СУБД.
   - MySQL: `INSERT ... ON DUPLICATE KEY UPDATE`
   - PostgreSQL: `INSERT ... ON CONFLICT DO UPDATE`
2. **Производительность** — массовые MERGE могут быть медленными на больших таблицах без правильных индексов.
3. **Триггеры и ограничения** — поведение может отличаться, особенно с внешними ключами и ограничениями уникальности.
4. **Одновременные операции** — при высокой конкуренции нужно быть осторожным с блокировками и гонками данных.

## **3.16. Какие агрегатные функции вы знаете?** {#3.16.-какие-агрегатные-функции-вы-знаете?}

**Агрегатные функции SQL**

Агрегатные функции позволяют выполнять вычисления над набором строк и получать одно итоговое значение для группы. Они часто используются вместе с `GROUP BY` для анализа данных.

**Основные функции:**

- `COUNT()` — считает количество строк в наборе результатов. Можно использовать `COUNT(DISTINCT column)` для подсчёта уникальных значений.
- `SUM()` — суммирует числовые значения столбца.
- `AVG()` — вычисляет среднее значение числового столбца.
- `MIN()` / `MAX()` — возвращают минимальное и максимальное значение соответственно.

**Работа со строками:**

- `GROUP_CONCAT()` / `STRING_AGG()` — объединяет строки в одну, используя разделитель. Отлично подходит для создания списков в одной колонке.

**Статистические функции:**

- `STDDEV()` / `STDEV()` — стандартное отклонение.
- `VARIANCE()` — дисперсия.
- `CORR()` — коэффициент корреляции между двумя числовыми столбцами.
- `COVAR_POP()` / `COVAR_SAMP()` — популяционная и выборочная ковариация.

**Аналитические функции (window functions):**

- `FIRST()` / `LAST()` — первое и последнее значение в группе.
- `PERCENTILE_CONT()` / `PERCENTILE_DISC()` — вычисляют перцентили.
- `CUME_DIST()` — накопительное распределение значений.
- `RANK()` / `DENSE_RANK()` — ранжируют значения в упорядоченном наборе данных.

**Агрегация в массивы и JSON:**

- `ARRAY_AGG()` / `JSON_AGG()` — собирают значения в массив или JSON-объект. Полезно для построения вложенных структур данных при аналитике или API.

**Практические советы на интервью:**

1. Многие функции доступны не во всех СУБД, поэтому важно знать аналоги для PostgreSQL, MySQL, SQL Server и Oracle.
2. Агрегатные функции можно комбинировать с `GROUP BY` и фильтровать с `HAVING`.
3. Window-функции (`RANK`, `CUME_DIST`) удобны для аналитики без потери исходных строк.
4. Для больших таблиц стоит обращать внимание на индексы и группировки — некоторые агрегаты (особенно `DISTINCT`, `GROUP_CONCAT`) могут быть ресурсоемкими.

## **3.17. Что такое ограничения (constraints)? Какие вы знаете?** {#3.17.-что-такое-ограничения-(constraints)?-какие-вы-знаете?}

Ограничения (constraints) в SQL \- это правила, устанавливаемые на столбцы таблицы, которые определяют, какие значения могут быть вставлены, обновлены или удалены в таблице.

Основные типы ограничений:

1. **Primary Key** — определяет уникальный идентификатор строки. Нельзя вставить дубликат и нельзя оставить `NULL`.

2. **Unique** — похож на первичный ключ, но может применяться к нескольким колонкам, и в отличие от PK может допускать `NULL`.

3. **Foreign Key** — обеспечивает ссылочную целостность между таблицами. Например, нельзя вставить заказ на несуществующего пользователя. Также можно задать поведение при удалении или обновлении (`CASCADE`, `SET NULL` и т. д.).

4. **Check** — кастомные условия на значения в колонке, например, чтобы возраст был больше 0 или дата окончания договора не раньше даты начала.

5. **Default** — задаёт значение по умолчанию для колонки, если при вставке оно не указано.

6. **Ограничения на удаление/обновление (ON DELETE / ON UPDATE)** — определяют поведение при изменении связанных записей: каскадное удаление, установка `NULL`, запрет и т. д.

На практике я стараюсь использовать ограничения максимально, потому что они убирают часть бизнес-логики из приложения и гарантируют защиту на уровне данных. Даже если где\-то в коде закралась ошибка, constraint не даст положить мусор в базу.

## **3.18. Что такое суррогатные ключи?** {#3.18.-что-такое-суррогатные-ключи?}

Суррогатный ключ — это искусственный первичный ключ, который не несёт бизнес-смысла и существует только для обеспечения уникальности строки. Чаще всего это авто_инкрементируемое число или UUID, которое генерируется базой при вставке записи.

Основные моменты:

- **Уникальность:** каждый суррогатный ключ гарантированно уникален.

- **Независимость от данных:** он не зависит от бизнес-атрибутов и не меняется при изменении данных.

- **Производительность:** сравнивать и индексировать целочисленный ключ проще и быстрее, чем, например, составной натуральный ключ из нескольких колонок.

- **Прозрачность:** для пользователей и бизнес-логики этот ключ, как правило, скрыт. Никто не будет опираться на `id` в реальном бизнес-контексте, он нужен только для связей и внутренней целостности.

Классический пример — поле `id SERIAL` в PostgreSQL или `AUTO_INCREMENT` в MySQL.

Обычно суррогатные ключи используют вместе с естественными ключами (например, email пользователя или артикул товара). Естественный ключ полезен для бизнес-логики, а суррогатный — для ссылочной целостности и стабильности схемы. Такой подход упрощает жизнь при рефакторинге: бизнес-атрибуты могут измениться, а суррогатный ключ останется тем же самым.

## **3.19. Чем TRUNCATE отличается от DELETE?** {#3.19.-чем-truncate-отличается-от-delete?}

Основное различие в том, что `TRUNCATE` — это DDL-операция, а `DELETE` — DML.

- **Скорость:** `TRUNCATE` работает быстрее, потому что не проходит по каждой строке и не пишет детальные записи в журнал транзакций. Он фактически пересоздаёт таблицу «с нуля» и сбрасывает автоинкрементные счётчики. `DELETE` идёт построчно, логгирует каждое удаление, поэтому на больших объёмах данных работает заметно медленнее.

- **Транзакции и откат:** `DELETE` можно откатить, потому что каждая операция фиксируется в журнале. `TRUNCATE` обычно не логгируется построчно и откатить его нельзя (в зависимости от конкретной СУБД — в некоторых можно, если команда выполняется внутри транзакции, но в целом полагаться на это рискованно).

- **Гибкость:** `DELETE` позволяет удалять строки выборочно через `WHERE`. `TRUNCATE` всегда убирает всё содержимое таблицы, никаких условий применить нельзя.

- **Побочные эффекты:** `TRUNCATE` сбрасывает автоинкременты (например, `AUTO_INCREMENT` или `SERIAL`). `DELETE` счётчик не трогает.

На практике я выбираю `TRUNCATE`, если нужно быстро очистить таблицу полностью, например, при подготовке тестовых данных. Если же нужна частичная очистка или требуется контроль транзакций — однозначно `DELETE`

## **3.20. Что такое хранимые процедуры? Для чего они нужны?** {#3.20.-что-такое-хранимые-процедуры?-для-чего-они-нужны?}

Хранимая процедура — это кусок SQL-кода, сохранённый в базе данных и выполняемый на стороне СУБД как единое целое. По сути, это «функция» внутри базы, которая может содержать бизнес-логику, работать с транзакциями и управлять данными без участия клиентского приложения.

Ключевые моменты:

- **Предварительная компиляция:** процедура компилируется один раз при создании, дальше выполняется быстрее, чем динамические запросы.

- **Повторное использование:** можно вызвать из разных приложений или сервисов, логика централизована.

- **Оптимизация сетевого трафика:** вместо отправки длинных SQL-запросов по сети, приложение вызывает процедуру, а база возвращает только результат.

- **Безопасность:** можно ограничить доступ так, чтобы пользователи могли выполнять процедуру, но не имели прямого доступа к таблицам.

- **Транзакции:** удобно инкапсулировать сложные операции в рамках одной транзакции.

- **Снижение дублирования:** одна процедура заменяет одинаковую логику в разных частях приложения.

Примеры применения: массовые вставки, агрегации, валидации данных, бизнес-операции уровня «создать заказ вместе с позициями».

На практике я отношусь к ним осторожно. В реляционных СУБД они удобны для инкапсуляции логики рядом с данными, но нужно учитывать минусы: сложнее версионировать, тестировать и переносить между СУБД. Поэтому я обычно держу бизнес-логику в приложении (например, на Go), а хранимые процедуры применяю точечно — там, где реально важна производительность

## **3.21. Что такое представления (VIEW)? Для чего они нужны?** {#3.21.-что-такое-представления-(view)?-для-чего-они-нужны?}

`VIEW` — это виртуальная таблица, которая формируется на основе SQL-запроса. Данные в ней физически не хранятся, они подтягиваются «на лету» из одной или нескольких таблиц при обращении к представлению.

Основные цели:

- **Абстракция и упрощение:** скрыть сложные SQL-запросы за более простым интерфейсом, чтобы разработчики работали с «чистой» таблицей.

- **Безопасность:** можно дать доступ к представлению с ограниченным набором колонок или строк вместо прямого доступа к таблицам.

- **Повторное использование:** если где\-то в системе много раз используется один и тот же сложный запрос, его можно вынести в `VIEW`, чтобы не дублировать код.

- **Сокрытие сложности:** особенно полезно, когда запрос объединяет несколько таблиц или делает агрегаты.

- **Виртуальная агрегация:** можно собрать данные из разных таблиц в одно место и использовать как источник для аналитики или отчётов.

На практике `VIEW` удобны, когда нужно раздать упрощённый или ограниченный доступ к данным другим командам или BI-системам. Но есть и подводные камни: сложные представления могут негативно влиять на производительность, особенно если в них много джойнов или агрегаций, а индексироваться напрямую они не могут. Поэтому я обычно использую их как средство для удобства и безопасности, но не как замену оптимизированных запросов или materialized view, если важна скорость.

## **3.22. Что такое временные таблицы? Для чего они нужны?** {#3.22.-что-такое-временные-таблицы?-для-чего-они-нужны?}

`VIEW` — это виртуальная таблица, которая формируется на основе SQL-запроса. Данные в ней физически не хранятся, они подтягиваются «на лету» из одной или нескольких таблиц при обращении к представлению.

Основные цели:

- **Абстракция и упрощение:** скрыть сложные SQL-запросы за более простым интерфейсом, чтобы разработчики работали с «чистой» таблицей.

- **Безопасность:** можно дать доступ к представлению с ограниченным набором колонок или строк вместо прямого доступа к таблицам.

- **Повторное использование:** если где\-то в системе много раз используется один и тот же сложный запрос, его можно вынести в `VIEW`, чтобы не дублировать код.

- **Сокрытие сложности:** особенно полезно, когда запрос объединяет несколько таблиц или делает агрегаты.

- **Виртуальная агрегация:** можно собрать данные из разных таблиц в одно место и использовать как источник для аналитики или отчётов.

На практике `VIEW` удобны, когда нужно раздать упрощённый или ограниченный доступ к данным другим командам или BI-системам. Но есть и подводные камни: сложные представления могут негативно влиять на производительность, особенно если в них много джойнов или агрегаций, а индексироваться напрямую они не могут. Поэтому я обычно использую их как средство для удобства и безопасности, но не как замену оптимизированных запросов или materialized view, если важна скорость.

## **3.23. Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?** {#3.23.-что-такое-нормализация-и-денормализация?-расскажите-про-3-нормальные-формы?}

Нормализация — это процесс структурирования данных в базе так, чтобы минимизировать избыточность и избежать аномалий при вставке, обновлении и удалении. Суть в том, чтобы данные были разложены по таблицам так, чтобы каждая таблица описывала одну сущность и хранила атомарные значения.

Три базовые нормальные формы:

- **1NF (первая нормальная форма):** таблица не содержит повторяющихся групп, и каждое поле хранит атомарное значение, без массивов или вложенных структур.

- **2NF (вторая нормальная форма):** выполняется 1NF, плюс все неключевые атрибуты зависят от всего первичного ключа, а не от его части (актуально для составных ключей).

- **3NF (третья нормальная форма):** выполняется 2NF, и отсутствуют транзитивные зависимости — то есть неключевые поля зависят только от ключа, а не друг от друга.

**Денормализация** — это обратный процесс: объединяем данные в одну таблицу, даже если появляется избыточность, ради ускорения выборок. Чаще всего это делается в аналитических системах (OLAP), где критичнее скорость запросов, чем строгое соблюдение нормализации.

На практике:

- Нормализация хорошо работает в OLTP-системах, где важны транзакции и целостность.

- Денормализация полезна для отчётности, дашбордов, аналитики, когда запросы должны выполняться быстро.

- Часто используют гибридный подход: храним данные в нормализованном виде, но для аналитики держим денормализованные витрины или materialized view.

## **3.24. Что такое TIMESTAMP?** {#3.24.-что-такое-timestamp?}

`TIMESTAMP` — это тип данных для хранения даты и времени в базе. Обычно он включает год, месяц, день, часы, минуты, секунды и при необходимости дробные секунды с заданной точностью. По сути, это «временная метка», которая однозначно фиксирует момент времени.

Есть нюансы в зависимости от СУБД:

- В некоторых базах (`Postgres`) `TIMESTAMP` может быть с часовым поясом (`TIMESTAMP WITH TIME ZONE`) или без него. Это важно, если система работает в распределённой среде.

- В `MySQL` `TIMESTAMP` отличается от `DATETIME` тем, что хранится в формате UTC и при выборке конвертируется в локальный часовой пояс, тогда как `DATETIME` просто хранит «как есть».

- Можно задавать точность до микросекунд.

Применение: логирование действий пользователей, хранение времени создания и изменения записей (`created_at`, `updated_at`), отслеживание событий, аналитика по временным промежуткам.

## **3.25. Что такое автовакуум в постгресе?** {#3.25.-что-такое-автовакуум-в-постгресе?}

Автовакуум в PostgreSQL — это фоновый процесс, который автоматически поддерживает базу в рабочем состоянии: чистит «мусорные» записи и обновляет статистику.

Зачем он нужен:

- **Удаление «мертвых» строк:** в Postgres при `UPDATE` и `DELETE` данные физически не затираются, а помечаются как неактуальные. Автовакуум реально освобождает эти места.

- **Освобождение пространства и предотвращение разрастания таблиц:** без вакуума таблицы только росли бы, даже при активных удалениях.

- **Обновление статистики:** планировщик запросов использует её, чтобы строить оптимальные execution plan.

- **Поддержание индексов:** автовакуум помогает избегать фрагментации и падения производительности.

Работает он в фоне и настраивается через параметры: можно регулировать частоту, пороги срабатывания, агрессивность. В высоконагруженных системах его поведение обычно тюнят под конкретные нагрузки, а иногда делают ручной `VACUUM` или `ANALYZE`, если нужно больше контроля.

На практике — автовакуум критически важен. Если его отключить или неправильно настроить, таблицы будут раздуваться, индексы деградировать, а производительность падать.

## **3.26. Что такое vacuum в PostgreSQL и когда его нужно запускать?** {#3.26.-что-такое-vacuum-в-postgresql-и-когда-его-нужно-запускать?}

ВВ PostgreSQL `VACUUM` — это процесс, который очищает таблицы от «мертвых» строк (tuple), оставшихся после `UPDATE` и `DELETE`. В отличие от некоторых других СУБД, Postgres не перезаписывает данные «на месте» — при обновлении создаётся новая версия строки, а старая помечается как устаревшая. Пока не запущен `VACUUM`, эти строки занимают место и могут замедлять работу.

Есть несколько режимов:

- **`VACUUM`** — освобождает место для повторного использования, но не уменьшает физический размер файла.

- **`VACUUM FULL`** — переписывает таблицу целиком, реально сжимая её на диске, но это тяжёлая операция с блокировкой.

- **`ANALYZE`** (часто используется вместе с `VACUUM`) — обновляет статистику для планировщика запросов.

Когда запускать:

- Обычно этим занимается **автовакуум** (AutoVacuum), который работает в фоне и автоматически чистит таблицы.

- Но вручную `VACUUM` или `VACUUM FULL` запускают, если:

  - таблица сильно фрагментирована,

  - резко выросло количество `UPDATE`/`DELETE`,

  - нужно освободить дисковое пространство,

# 4 Индексы {#4-индексы}

## **4.1. Что такое индекс?** {#4.1.-что-такое-индекс?}

Индекс — это структура данных, которая позволяет быстро находить данные в базе данных. Индексы используются для ускорения поиска данных в базе данных.

## **4.2. Какие бывают индексы?** {#4.2.-какие-бывают-индексы?}

Индексы бывают нескольких типов:

- Кластерные (clustered) индексы. Кластерный индекс определяет порядок данных в таблице. Таблица может иметь только один кластерный индекс.
- Некластерные (nonclustered) индексы. Некластерный индекс не определяет порядок данных в таблице. Таблица может иметь несколько некластерных индексов.
- Покрывающие (covering) индексы. Покрывающий индекс содержит все данные, которые нужны для выполнения запроса. Покрывающие индексы позволяют избежать обращения к таблице.

## **4.3. Пример работы покрывающего индекса** {#4.3.-пример-работы-покрывающего-индекса}

`![][image3]![][image4]`

## **4.4. Какие структуры данных используются в индексах PostgreSQL?** {#4.4.-какие-структуры-данных-используются-в-индексах-postgresql?}

В PostgreSQL индексы — это структуры данных, которые **ускоряют поиск и фильтрацию данных в таблицах**. Они не хранят сами данные, а содержат ссылки на строки таблицы, организованные так, чтобы можно было быстро найти нужные записи. PostgreSQL поддерживает несколько типов структур для индексов, каждая подходит для определенных сценариев:

**1\. B-дерево (B-tree)**

- Самый распространённый тип индекса в PostgreSQL.
- Отлично подходит для **сортированных данных и диапазонных запросов** (`<`, `>`, `BETWEEN`, `ORDER BY`).
- Подходит для обычных уникальных и неуникальных индексов.

**2\. Составной индекс (Composite index)**

- Создаётся на **нескольких столбцах** таблицы.
- Помогает ускорять запросы с фильтрацией или сортировкой по нескольким колонкам одновременно.
- Важно помнить порядок колонок — он влияет на эффективность.

**3\. GIN (Generalized Inverted Index)**

- Эффективен для **поиска по массивам, JSONB, hstore и полнотексту**.
- Подходит для случаев, когда нужно искать по множеству значений внутри одного поля.
- Используется в `@>`, `?`, `@@` и других операциях поиска.

**4\. GiST (Generalized Search Tree)**

- Универсальная структура, которую можно настраивать под **геоданные, полнотекстовый поиск и сложные пользовательские типы**.
- Используется для запросов, где простые B-tree индексы неэффективны, например, пространственные данные (`PostGIS`) или R-tree–подобные поиски.

**5\. Hash-индексы**

- Используются для поиска по **точному совпадению значения**.
- Работают быстро при точных фильтрах (`=`), но в PostgreSQL их использование ограничено: они не поддерживают сортировку и диапазонные запросы.

##

##

## **4.5. Часто задаваемый вопрос по индексам PostgreSQL, различие между B-деревом и хеш-таблицей** {#4.5.-часто-задаваемый-вопрос-по-индексам-postgresql,-различие-между-b-деревом-и-хеш-таблицей}

B-дерево используется для определения записей в сравнении больше / меньше / равно, а хеш-таблица используется для определения записей в сравнении равно. То есть B-дерево может использоваться для поиска по диапазону, а хеш-таблица \- нет.

## **4.6. Как снизить нагрузку с помощью индексов?** {#4.6.-как-снизить-нагрузку-с-помощью-индексов?}

**1\. Ускорение поиска**

- Индексы позволяют быстро находить строки по условиям `WHERE`, `JOIN` и `ORDER BY`.
- Создание индексов на часто используемых колонках существенно сокращает время выполнения запросов.

**2\. Снижение нагрузки при фильтрации**

- С индексом СУБД обрабатывает только релевантные строки, уменьшая нагрузку на CPU и память.
- Особенно эффективно для больших таблиц.

**3\. Оптимизация соединений (JOIN)**

- Индексы на колонках, участвующих в `JOIN`, ускоряют поиск совпадений между таблицами.
- Без индекса соединение требует полного сканирования таблиц → дорого по ресурсам.

**4\. Сортировка и группировка (ORDER BY / GROUP BY)**

- Индексы позволяют СУБД быстрее сортировать и группировать данные, используя уже упорядоченную структуру.

**5\. Поиск по первичному ключу (PRIMARY KEY)**

- Первичный ключ автоматически индексируется.
- Поиск по уникальному идентификатору становится мгновенным, что снижает нагрузку на систему.

Индексы ускоряют чтение, но **замедляют вставку и обновление**, т.к. их нужно поддерживать.

Подбор правильных типов данных (например, `INT` вместо `VARCHAR` для чисел) повышает эффективность индекса и поиска.

## **4.7. Почему нельзя повесить индекс на каждый столбец?** {#4.7.-почему-нельзя-повесить-индекс-на-каждый-столбец?}

**1\. Потребление ресурсов**

- Каждый индекс занимает место на диске и частично в памяти.
- Если индексировать все столбцы, таблица будет весить гораздо больше, что увеличивает нагрузку на I/O и кеширование.

**2\. Замедление операций записи**

- При вставке, обновлении или удалении строк нужно поддерживать все индексы в актуальном состоянии.
- Для B-дерева (B-tree), который PostgreSQL использует по умолчанию, перестройка индекса занимает `O(log n)` времени для каждой записи.
- Чем больше индексов, тем выше стоимость каждой записи: вставка, обновление или удаление становится медленнее.

**3\. Сложность поддержки**

- Множество индексов усложняет администрирование: пересоздание, VACUUM, анализ статистики.
- Растёт риск избыточных или дублирующих индексов, которые фактически не ускоряют запросы.

Индексы — это **баланс между чтением и записью**. Нужно индексировать **только те столбцы, по которым реально часто ищут, сортируют или делают JOIN**.

## **4.8. Селективность в составном индексе** {#4.8.-селективность-в-составном-индексе}

**Селективность** — это параметр индекса, показывает, насколько уникальны значения относительно размера таблицы.

Чем выше селективность, тем меньше строк соответствует конкретному значению, и тем эффективнее индекс помогает фильтровать данные.

**Составной индекс** — это индекс на нескольких столбцах, например `(A, B)`.

Селективность составного индекса зависит от **селективности каждого столбца и их порядка**.

- Столбец `A` — высокоселективный (много уникальных значений)
- Столбец `B` — низкоселективный (мало уникальных значений).

Индекс `(A, B)` будет **лучше**, чем `(B, A)`, потому что фильтрация сначала по `A` сразу отбрасывает большую часть строк, а затем уже применяется фильтр по `B`.

При создании составных индексов **ставьте сначала самые селективные столбцы**, если запросы фильтруют по нескольким колонкам.

## **4.9. Отфильтрованные индексы** {#4.9.-отфильтрованные-индексы}

Отфильтрованные индексы (или **partial indexes**) — это индексы, которые создаются не на всей таблице, а **только на подмножество строк**, удовлетворяющих заданному условию. Они полезны, когда нужно ускорить выборку определенного типа данных.

**Основные преимущества**

1. **Экономия места**

- Индекс хранит только строки, соответствующие условию, поэтому занимает меньше дискового пространства.

2. **Ускорение запросов**

- Меньший индекс \= меньше страниц для сканирования. Запросы, которые используют этот индекс, выполняются быстрее.

3. **Меньшее обслуживание**

- Перестроение и обновление индекса занимает меньше времени, так как индекс содержит только часть данных.

**🔹 Пример в PostgreSQL**  
`CREATE INDEX idx_filtered_example`  
`ON your_table (column_name)`  
`WHERE condition;`

- `idx_filtered_example` — имя индекса.
- `your_table` — таблица, на которой создаем индекс.
- `column_name` — колонка для индексации.
- `condition` — фильтр, определяющий, какие строки войдут в индекс.

**🔹 Когда использовать**

- Когда **подмножество данных** часто запрашивается, а остальные строки редко.
- Когда важно **сэкономить место** и **снизить нагрузку на обновления**.

## **4.10. Добавление неиспользуемых полей в индекс** {#4.10.-добавление-неиспользуемых-полей-в-индекс}

Добавление полей в индекс, которые фактически **не используются в запросах**, — это плохая практика. Такой подход не даёт выгоды, но создаёт ряд проблем для производительности базы данных.

Почему это плохо

1. **Увеличение размера индекса**

- Каждое поле добавляет данные в индекс.
- Неиспользуемые поля только занимают место на диске и в памяти, без пользы для ускорения запросов.

2. **Замедление операций записи**

- При вставке, обновлении или удалении PostgreSQL нужно поддерживать все индексы в актуальном состоянии.
- Чем больше индекс (особенно с лишними полями), тем дороже эти операции по CPU и I/O.

Рекомендации

- Индексировать **только те столбцы**, которые реально используются в запросах.
- Использовать инструменты анализа запросов:
  - `EXPLAIN` / `EXPLAIN ANALYZE` для оценки плана выполнения.
  - `pg_stat_statements` и `pg_stat_activity` для мониторинга нагрузки и поиска горячих точек.
- Проводить регулярный аудит индексов, удаляя или пересоздавая лишние.

#

# 7 Операторы и операции {#7-операторы-и-операции}

-

## **7.24. Если у нас у колонки три уникальных значения, есть ли смысл делать индекс по этому полю? (селективность и кардинальность)** {#7.24.-если-у-нас-у-колонки-три-уникальных-значения,-есть-ли-смысл-делать-индекс-по-этому-полю?-(селективность-и-кардинальность)}

В такой ситуации индекс почти всегда бесполезен. Причина в низкой **кардинальности** (всего три уникальных значения) и, соответственно, слабой **селективности**. Индексы эффективны, когда они позволяют быстро отобрать небольшой поднабор строк. Но если, скажем, каждое значение встречается в десятках тысяч строк, СУБД проще сделать full table scan, чем ходить по индексу и потом вытаскивать все эти записи.

Есть редкие случаи, когда индекс на колонке с низкой кардинальностью может пригодиться:

- если эта колонка участвует в составном индексе с другими более селективными полями;

- если запросы фильтруют именно по «редкому» значению, например `status = 'archived'`, которое реально встречается редко (1–2% строк).

Но в общем случае индекс на поле с тремя значениями будет только занимать место и замедлять `INSERT/UPDATE/DELETE`.

На практике я обычно смотрю на статистику использования запросов и на распределение значений. Если селективность низкая — индекс не создаю.

## **7.25. Как примерно прикинуть количество строк в таблице?** {#7.25.-как-примерно-прикинуть-количество-строк-в-таблице?}

1. **Системные метаданные:** большинство СУБД хранят статистику по таблицам. В PostgreSQL, например, можно посмотреть в `pg_class.reltuples` или во вьюхах вроде `pg_stat_user_tables`. Это даст приближённое число строк.

2. **Статистика планировщика:** Postgres поддерживает функции вроде `pg_stat_get_live_tuples`, которые возвращают оценку количества «живых» строк (т. е. без удалённых).

3. **Через индексы:** можно посмотреть статистику по индексам, если они покрывают все строки, но это будет тоже оценка.

4. **EXPLAIN:** иногда используют `EXPLAIN` для запроса `SELECT * FROM table;` — планировщик покажет предполагаемое количество строк, основываясь на своей статистике.

5. **Грубый расчёт по размеру:** берём размер таблицы на диске (например, через `pg_relation_size`) и делим на средний размер строки. Это очень грубая оценка, но иногда полезна.

На практике: если нужна точная цифра — делаем `COUNT(*)`, но это дорого для больших таблиц. Если нужна прикидка для планирования запросов или анализа производительности — используем статистику СУБД.

## **7.26. Консенсус** {#7.26.-консенсус}

Консенсус — это механизм, позволяющий узлам распределённой системы договориться об общем состоянии или решении, даже если часть узлов вышла из строя или сеть работает с задержками. Он критически важен для согласованности данных в кластерах БД, распределённых файловых системах и сервисах координации.

Ключевые свойства:

- **Атомарность:** решение либо принимается всеми, либо никем.

- **Согласованность:** все участники приходят к одному и тому же результату.

- **Устойчивость:** принятое решение сохраняется и после сбоев или перезапуска.

- **Толерантность к сбоям:** консенсус должен достигаться, даже если часть узлов работает некорректно.

Классический алгоритм — **Paxos**, но он довольно сложен для практической реализации. Поэтому чаще применяют **Raft** (например, в etcd, Consul) или **Zab** (в ZooKeeper), которые проще для понимания и внедрения.

На практике консенсус нужен для:

- согласованной репликации данных,
- выбора лидера в кластере,
- обеспечения корректной работы распределённых транзакций.

Без механизма консенсуса в распределённой системе мы можем получить split-brain или разные узлы будут видеть разные состояния данных.

## **7.27. Дебаг медленных запросов.** {#7.27.-дебаг-медленных-запросов.}

Дебаг медленных запросов — это комбинация анализа плана выполнения, проверки индексов и мониторинга нагрузки. Обычно я действую так:

1. **Сначала план выполнения.** В PostgreSQL это `EXPLAIN`/`EXPLAIN ANALYZE`. Смотрю, где узкие места: Seq Scan вместо Index Scan, дорогие JOIN’ы, сортировки без индексов.

2. **Логирование.** Включаю `log_min_duration_statement`, чтобы понять, какие запросы реально тормозят в проде.

3. **Анализ в контексте приложения.** Проверяю, нет ли N+1 запросов со стороны ORM или избыточных SELECT’ов. Иногда проблема не в БД, а в коде.

4. **Индексы.** Оптимизирую: добавляю недостающие, убираю лишние, смотрю на селективность. Если индекс не помогает — возможно, данные слишком перекошены.

5. **Архитектурные шаги.** Если проблема в больших объёмах данных — партиционирование, денормализация, кэширование (Redis, Materialized Views).

6. **Конфигурация БД.** Иногда достаточно подстроить work_mem, shared_buffers или parallel workers.

7. **Мониторинг.** Смотрю статистику из `pg_stat_statements`, чтобы видеть частоту и среднее время выполнения запросов.

В итоге стратегия простая: сначала находишь «бутылочное горлышко» через EXPLAIN/логи, потом решаешь, что оптимизировать — запрос, индексы, схему или саму конфигурацию БД.

## **7.28. Логическое партиционирование.** {#7.28.-логическое-партиционирование.}

Логическое партиционирование — это способ разбить большую таблицу на несколько частей (партиций) по какому-то критерию: например, по дате, диапазону значений, категории или региону. В итоге мы работаем не с гигантской таблицей целиком, а только с нужным кусочком данных.

Ключевые плюсы:

- **Производительность.** Запросы быстрее, потому что они обращаются только к нужной партиции, а не ко всей таблице.

- **Управляемость.** Проще оперировать данными — можно удалять/архивировать целые партиции, а не миллионы строк.

- **Обслуживание.** Индексы, вакуум, оптимизация — всё это можно делать отдельно для каждой партиции.

- **Масштабируемость.** Добавление новых партиций позволяет безболезненно растить систему.

- **Гибкость.** Можно распределять партиции по разным серверам или даже использовать для разграничения доступа.

Простой пример: есть таблица логов за много лет. Вместо одной огромной таблицы можно завести партиции по месяцам или годам. Тогда свежие запросы будут ходить только в актуальные данные, а старые партиции можно архивировать или перенести на дешёвое хранилище.

## **7.29. Как можно оценить работу кэша? Что можно кэшировать?** {#7.29.-как-можно-оценить-работу-кэша?-что-можно-кэшировать?}

Оценка работы кэша обычно строится на метриках. Ключевые показатели:

- **Объём памяти под кэш** — базовый ресурсный показатель.

- **RPS чтения/записи.** В норме чтений должно быть в разы больше, чем записей. Если наоборот — кэш работает неэффективно.

- **Количество элементов в кэше** — помогает отлавливать слишком большие записи.

- **Hit rate.** Самый главный показатель: насколько часто данные берутся из кэша, а не из источника.

- **Expired rate.** Процент записей, удалённых из\-за истечения TTL. Если он высок — возможно, TTL выставлен неправильно.

- **Eviction rate.** Процент вытеснений из\-за нехватки памяти. Важно для выбора стратегии вытеснения (LRU, LFU и т.д.).

Что кэшировать:

- **Часто изменяющиеся данные** (секунды/минуты) почти не имеет смысла кэшировать, разве что ошибки или специфичные кейсы.

- **Нечасто изменяющиеся данные** (минуты/часы/дни) — основной кандидат. Примеры: списки товаров, их описания, агрегированные данные.

- **Редко изменяющиеся данные** (недели/годы) можно смело кэшировать, но всегда выставлять TTL — нет данных, которые не меняются «никогда».

На практике я обычно начинаю с анализа паттернов запросов: что чаще всего читается и насколько данные стабильны. Дальше настраиваю метрики, слежу за hit rate и eviction rate — и уже по ним оптимизирую стратегию.

## **7.30. Планировщик запросов в postgresql. Explain и explain analyse.** {#7.30.-планировщик-запросов-в-postgresql.-explain-и-explain-analyse.}

В PostgreSQL планировщик запросов — это компонент, который выбирает оптимальный способ выполнения SQL-запроса. Его задача — среди множества возможных планов (например, сканирование по индексу или полный проход по таблице, разный порядок JOIN’ов, методы сортировки) выбрать тот, который будет дешевле всего по оценочной «стоимости» с учётом статистики данных.

Основные шаги работы планировщика:

1. **Анализ SQL.** Определяет, какие таблицы, столбцы, фильтры и соединения участвуют.

2. **Генерация планов.** Строит несколько возможных стратегий выполнения.

3. **Оценка стоимости.** Использует статистику (селективность, кардинальность, размеры таблиц/индексов).

4. **Выбор плана.** Берёт наименее затратный и отдаёт его на исполнение.

5. **Выполнение.** Запрос идёт по выбранному пути, но PostgreSQL может динамически корректировать поведение (например, для `LIMIT`).

Теперь про инструменты:

**EXPLAIN** — показывает план выполнения без фактического запуска. Полезно, когда хочешь понять, как запрос будет исполняться, и проверить, будет ли использован индекс.

`EXPLAIN SELECT * FROM customers WHERE age > 30;`

**EXPLAIN ANALYZE** — реально выполняет запрос и даёт статистику: время по каждому шагу, количество обработанных строк, где были отклонения от прогнозов планировщика.

`EXPLAIN ANALYZE SELECT * FROM customers WHERE age > 30;`

На практике я обычно начинаю с `EXPLAIN`, чтобы понять план, а если хочу проверить реальную производительность и узкие места — использую `EXPLAIN ANALYZE`. В связке они позволяют оптимизировать запросы и понять, почему СУБД выбрала тот или иной путь.

## **7.31. Что такое deadlock в PostgreSQL?** {#7.31.-что-такое-deadlock-в-postgresql?}

Deadlock \- это ситуация, при которой два или более процесса заблокированы, потому что каждый из них ждет ресурс, который удерживает другой процесс.

PostgreSQL обнаруживает ситуации deadlock и предпринимает попытки разрешить их автоматически. Это может включать в себя прерывание одной из блокирующих транзакций, чтобы разблокировать другую. Однако автоматическое разрешение deadlock может потребовать отката части транзакции, что может повлиять на целостность данных, поэтому это следует учитывать при проектировании базы данных и приложений.

## **7.32. Как можно обнаружить deadlock в PostgreSQL?** {#7.32.-как-можно-обнаружить-deadlock-в-postgresql?}

Deadlock возникает, когда две или более транзакции блокируют ресурсы и ждут друг друга, из\-за чего ни одна не может продолжить выполнение. В PostgreSQL есть несколько способов обнаружить и диагностировать такие ситуации:

1. **Автоматическое обнаружение:** PostgreSQL сам детектирует deadlock и прерывает одну из транзакций, выдавая ошибку `ERROR: deadlock detected`. В логи пишется подробная информация о транзакциях и заблокированных ресурсах.

2. **Логирование долгих ожиданий:** можно включить параметры `log_lock_waits = on` и `deadlock_timeout`, чтобы фиксировать ситуации, когда транзакции ждут блокировку слишком долго.

**Системные представления:** в современных версиях PostgreSQL поле `waiting` устарело. Вместо этого используют `wait_event_type` и `wait_event` в `pg_stat_activity`, чтобы увидеть все транзакции, которые ожидают ресурсы:  
`SELECT pid, usename, query, state, wait_event_type, wait_event`  
`FROM pg_stat_activity`  
`WHERE state = 'active' AND wait_event IS NOT NULL;`

3.  Этот запрос показывает потенциальные блокировки. Важно понимать, что не каждое ожидание — это deadlock, но такие данные помогают локализовать проблемные транзакции.

4.  **Анализ блокировок вручную:** можно использовать `pg_locks` совместно с `pg_stat_activity`, чтобы увидеть, какие транзакции держат и ждут блокировки. Это полезно для построения графа зависимостей и выявления циклов, ведущих к deadlock.

5.  **EXPLAIN и профилирование транзакций:** иногда deadlock вызван определённым порядком операций над таблицами. Анализ порядка доступа к ресурсам и профилирование запросов помогают предотвратить повторение.

**Итог:** стратегия диагностики — мониторинг длительных блокировок через `pg_stat_activity` и `pg_locks`, логирование долгих ожиданий, анализ ошибок deadlock в логах и корректировка порядка транзакций.

## **7.33. Что такое многоверсионность в PostgreSQL?** {#7.33.-что-такое-многоверсионность-в-postgresql?}

Многоверсионность в PostgreSQL — это механизм, который позволяет одновременно читать и изменять данные без блокировок. Она критически важна для обеспечения высокой конкурентности и целостности данных, особенно в системах с большим количеством параллельных транзакций.

PostgreSQL использует концепцию **MVCC (Multi-Version Concurrency Control)**. Каждая транзакция видит свой собственный «снимок» данных, и изменения одной транзакции не мешают другой до момента фиксации (commit).

Основные моменты, которые стоит понимать:

1. **Снимки данных (Snapshots)**

   - Каждая транзакция работает с версией данных на момент её старта.
   - Это позволяет параллельно выполнять чтение и запись без блокировки строк, что сильно повышает производительность.

2. **MVCC**
   - Каждая строка в таблице хранит метаданные о времени создания и удаления.
   - Когда транзакция делает запрос, она видит только «живые» строки, актуальные на момент её старта.
3. **Изоляция транзакций**
   - MVCC обеспечивает высокий уровень изоляции: каждая транзакция видит свой собственный снимок данных.
   - Это предотвращает «грязное» чтение и позволяет безопасно параллелить операции.
4. **Одновременные чтение и запись**
   - Благодаря многоверсионности PostgreSQL может обрабатывать множество операций чтения и записи одновременно.
   - Это критично для сервисов с высокой нагрузкой и большим количеством пользователей.
5. **Работа с большими объемами данных**
   - MVCC и снимки позволяют эффективно масштабировать систему и сохранять производительность даже при интенсивной многозадачности.
6. **ACID**
   - Многоверсионность помогает PostgreSQL полностью поддерживать ACID-транзакции: атомарность, согласованность, изоляцию и долговечность.

## **7.34. Что такое WAL в PostgreSQL?** {#7.34.-что-такое-wal-в-postgresql?}

WAL — это **журнал предзаписи**, который фиксирует все изменения данных **до того, как они попадут в основную базу**. Проще говоря, это механизм безопасности и восстановления: если система падает или происходит сбой, PostgreSQL использует WAL для восстановления данных до последнего согласованного состояния.

Ключевые моменты:

1. **Предотвращение потери данных**

   - Все изменения сначала записываются в WAL, затем в основную таблицу.

   - Даже если база не успела записать изменения на диск, WAL гарантирует, что они не потеряются.

2. **Восстановление после сбоя**

   - При рестарте PostgreSQL читает WAL и воспроизводит все изменения, которые ещё не были применены к основным файлам данных.

3. **Производительность**

   - WAL позволяет PostgreSQL выполнять операции записи эффективнее, так как журнал последовательный, а не случайный, что снижает накладные расходы на I/O.

4. **Репликация и резервное копирование**

   - WAL активно используется для потоковой репликации и создания резервных копий, обеспечивая консистентное состояние базы на разных серверах.

## **7.35. Как ускорить работу с базой данных** {#7.35.-как-ускорить-работу-с-базой-данных}

**Индексация**

- Создавайте индексы на колонках, которые участвуют в фильтрах, join’ах и сортировках.
- Индексы позволяют базе данных быстро находить нужные записи без полного сканирования таблицы.

**Оптимизация SQL-запросов**

- Пересмотрите запросы: уменьшайте количество отдельных вызовов, выбирайте более эффективные операторы и используйте подзапросы там, где это оправдано.

**Кэширование**

- Кэшируйте результаты часто выполняемых запросов в памяти (например, Redis или Memcached).
- Это снижает нагрузку на базу и ускоряет повторный доступ к данным.

**Масштабирование**

- **Вертикальное** — увеличивайте ресурсы существующего сервера.
- **Горизонтальное** — добавляйте дополнительные узлы для распределения нагрузки.

**Индексированные представления**

- Если есть часто используемые сложные запросы, создавайте материализованные или индексированные представления.

**Ограничение объема данных**

- Удаляйте устаревшие записи и архивируйте редко используемые данные.
- Меньший объем данных ускоряет выполнение запросов.

**Оптимизация сетевых запросов**

- Снижайте количество и объем запросов между клиентом и сервером.
- Используйте батчинг и lazy-загрузку там, где это возможно.

**Использование NoSQL для специфичных задач**

- Для сценариев с низкой структурированностью данных NoSQL может дать существенный прирост скорости.

**Мониторинг и профилирование**

- Используйте инструменты мониторинга, чтобы выявлять медленные запросы и узкие места.
- Это помогает принимать целенаправленные решения по оптимизации.

# 8 Оптимизация и диагностика {#8-оптимизация-и-диагностика}

## **8.1. Способы оптимизации запросов** {#8.1.-способы-оптимизации-запросов}

**Индексация**

- Создавайте индексы на колонках, которые участвуют в `WHERE` и `JOIN`.
- Это ускоряет поиск и выборку данных.

**Эффективное написание запросов**

- Выбирайте только необходимые поля (`SELECT *` — зло).
- Избегайте `LIKE` с подстановочными символами в начале строки, так как это блокирует использование индексов.

**Ограничение выборки**

- Используйте `LIMIT` или аналогичные механизмы, чтобы не обрабатывать лишние данные.

**Кэширование**

- Результаты часто выполняемых запросов можно кэшировать в памяти или через Redis/Memcached.
- Это уменьшает нагрузку на базу и ускоряет повторный доступ.

**Разбиение сложных запросов**

- Сложные `JOIN`\-запросы можно разделять на несколько последовательных запросов для улучшения читаемости и производительности.

**Индексированные представления**

- Для часто используемых запросов создавайте материализованные или индексированные представления.

**Подзапросы и функции**

- Используйте подзапросы для повышения читаемости, но избегайте функций в `WHERE` на индексируемых колонках — они мешают оптимизатору использовать индексы.

**Оптимизация JOIN**

- Используйте `INNER JOIN`, если внешние соединения не нужны.
- Убедитесь, что колонки для `JOIN` проиндексированы.

**Профилирование и анализ**

- Используйте инструменты профилирования СУБД для выявления медленных участков.

- Изучайте планы выполнения (`EXPLAIN`), чтобы оптимизировать тяжелые операции.

**Обновление статистики**

- Регулярно обновляйте статистику, чтобы оптимизатор создавал эффективные планы запросов.

**Удаление лишних индексов**

- Удаляйте неиспользуемые индексы, чтобы снизить накладные расходы на обслуживание.

**Масштабирование базы данных**

- Вертикальное (увеличение ресурсов) или горизонтальное (добавление серверов) масштабирование помогает справляться с ростом нагрузки.

**Кэширование на уровне приложения**

- Для редко изменяемых данных можно использовать локальный кэш в приложении, снижая нагрузку на базу..

## **8.2. Инструменты для профилирования запросов** {#8.2.-инструменты-для-профилирования-запросов}

Профилирование запросов — ключевой инструмент для оптимизации производительности базы данных. Оно позволяет выявлять медленные запросы, узкие места и точки для оптимизации. Основные инструменты:

1. **PostgreSQL**

   - `pg_stat_statements` — встроенный модуль, отслеживающий все выполненные SQL-запросы. Показывает количество вызовов, время выполнения, используемые индексы и другие метрики.

   - `EXPLAIN` — позволяет анализировать план выполнения запроса: какие индексы будут использованы, какие операции выполняются.

   - `pgBadger` — утилита для анализа логов PostgreSQL. Генерирует отчеты и графики по медленным запросам.

2. **MySQL**

   - `MySQL Enterprise Monitor` — коммерческий инструмент мониторинга и профилирования запросов. Отображает статистику выполнения и помогает выявлять узкие места.

3. **Microsoft SQL Server**

   - `SQL Server Profiler` — инструмент для мониторинга выполнения запросов в реальном времени и анализа их производительности.

4. **Oracle Database**

   - `Query Profiler` — встроенный инструмент для анализа запросов. Предоставляет статистику времени выполнения, использованных индексов и других метрик.

5. **Облачные и универсальные инструменты**

   - `New Relic`, `Datadog`, `AppOptics` — сервисы мониторинга производительности, которые интегрируются с различными СУБД и предоставляют метрики выполнения запросов, визуализацию и анализ.

   - `Percona Toolkit` — набор утилит для администрирования и оптимизации баз данных, включая инструменты для профилирования запросов.

## **8.3. Как использовать различные типы связей** {#8.3.-как-использовать-различные-типы-связей}

**Один-к-Одному (One-to-One)**

- Каждая запись в одной таблице соответствует ровно одной записи в другой.
- **Пример:** Таблицы `Пользователи` и `Профили`. Каждый пользователь имеет один профиль.
- **Использование:** Хранение дополнительных данных, которые не нужны в основной таблице, уменьшение избыточности.

**Один-ко-Многим (One-to-Many)**

- Одна запись в таблице связана с несколькими записями в другой таблице.
- **Пример:** `Заказы` и `Позиции заказов`. Один заказ может иметь несколько позиций.
- **Использование:** Организация данных, когда одна сущность может иметь несколько связанных записей.

**Многие-к-Одному (Many-to-One)**

- Несколько записей в одной таблице связаны с одной записью в другой таблице.
- **Пример:** `Продукты` и `Категории`. Несколько продуктов принадлежат одной категории.
- **Использование:** Классификация и группировка данных.

**Многие-ко-Многим (Many-to-Many)**

- Несколько записей в одной таблице связаны с несколькими записями в другой таблице.
- **Пример:** `Студенты` и `Курсы`. Множество студентов может посещать множество курсов.
- **Использование:** Описание сложных отношений между сущностями. Обычно реализуется через промежуточную таблицу.

**Самосвязь (Self-Referencing)**

- Таблица связана сама с собой.
- **Пример:** `Сотрудники` с полем `Руководитель`. Каждый сотрудник может быть руководителем для других.
- **Использование:** Организация иерархий и древовидных структур данных.

## **8.4. Какие блокировки существуют и когда используются** {#8.4.-какие-блокировки-существуют-и-когда-используются}

Блокировки нужны для управления параллельным доступом к данным и предотвращения конфликтов.

1. **Shared Lock (S-lock)**
   - Разрешает нескольким процессам одновременно читать данные.
   - Используется для параллельного доступа к данным без конфликтов при чтении.
2. **Exclusive Lock (X-lock)**
   - Блокирует доступ для других процессов до снятия блокировки.
   - Используется для операций записи, чтобы гарантировать эксклюзивный доступ.
3. **Update Lock (U-lock)**
   - Позволяет одному процессу обновлять данные, не блокируя чтение другими, но блокируя другие обновления.
   - Применяется для уменьшения конфликтов при обновлении строк.
4. **Intent Lock**
   - Указывает намерение процесса поставить более высокоуровневую блокировку.
   - Пример: `INTENT SHARE (IS)` показывает, что процесс собирается получить S-lock.
   - Используется для снижения вероятности блокировок на уровне таблиц или страниц.
5. **Schema Lock**
   - Блокирует доступ к структуре таблиц или схемы базы данных.
   - Применяется при изменении структуры таблицы (`ALTER TABLE`) или создании индексов.
6. **Row-Level Lock**
   - Блокирует отдельные строки, а не всю таблицу.
   - Позволяет минимизировать конфликты при параллельной работе с разными строками.
7. **Page-Level Lock**
   - Блокирует страницы данных внутри таблицы.
   - Используется в некоторых СУБД для оптимизации работы с большими объемами данных.
8. **Table-Level Lock**
   - Блокирует всю таблицу целиком.
   - Применяется редко, так как сильно снижает параллельность и производительность.

Выбор блокировки зависит от операции и требований приложения:

- Для чтения — **Shared Lock**.
- Для записи — **Exclusive Lock**.
- Для обновлений с минимальными конфликтами — **Update Lock**.

Важно следить за **временем удержания блокировок** и использовать их бережно, чтобы не снижать производительность и не создавать “узкие места” в работе системы.

## **8.5. Как оптимизировать миграции** {#8.5.-как-оптимизировать-миграции}

1. **Разделяйте миграции на мелкие шаги**
   - Вместо одной большой миграции делайте несколько небольших.
   - Упрощает откат и управление изменениями.
2. **Оптимизируйте индексы**
   - Не создавайте лишние индексы.
   - Проверяйте, что индексы соответствуют реальным запросам приложения.
3. **Используйте асинхронные миграции**
   - Если СУБД поддерживает, выполняйте миграции асинхронно.
   - Это ускоряет процесс без остановки приложения.
4. **Оптимизируйте SQL-запросы**
   - Проверяйте запросы в миграциях, ищите более эффективные способы выполнения операций.
5. **Устанавливайте ограничения времени выполнения**
   - Длительные миграции могут блокировать работу приложения.
   - Ограничения времени помогут избежать долгого простоя.
6. **Используйте мониторинг**
   - Следите за производительностью миграций и выявляйте узкие места.
7. **Тестируйте миграции и откаты**
   - Обязательно проверяйте каждую миграцию на тестовой базе.
   - Тестируйте возможность отката вместе с миграциями.
8. **Мигрируйте постепенно**
   - Если возможно, переносите данные партиями, а не сразу всю базу.
   - Снижает риск ошибок и нагрузку на систему.
9. **Ведите журнал миграций**
   - Записывайте, какие миграции применены и когда.
   - Помогает отслеживать историю изменений.
10. **Используйте инструменты автоматизации**
    - Flyway, Liquibase, Alembic и другие помогают управлять версиями миграций и упрощают процесс.
11. **Резервное копирование и безопасность**
    - Всегда делайте бэкапы перед применением миграций.
    - Обеспечивайте целостность и сохранность данных.

**Вывод:**  
 Оптимизация миграций — это комбинация **малых шагов, тестирования, мониторинга и правильного управления индексами**.

## **8.6. Что такое партиционирование, как и когда использовать** {#8.6.-что-такое-партиционирование,-как-и-когда-использовать}

Партиционирование — это метод организации больших таблиц, когда данные разбиваются на **подмножества (партиции)**. Каждая партиция обрабатывается как отдельная таблица, но остаётся частью одной логической таблицы. Это помогает эффективно управлять большими объёмами данных.

**Когда и зачем использовать партиционирование:**

1. **Улучшение производительности чтения и записи**
   - Разделение данных на партиции позволяет быстрее выполнять запросы и обрабатывать данные параллельно.
2. **Управление историческими данными**
   - Позволяет легко архивировать или удалять старые данные без воздействия на текущие данные.
3. **Партиционирование по времени**
   - Полезно для анализа и агрегации данных по дням, месяцам или годам.
4. **Обработка больших объёмов данных**
   - Делает работу с огромными таблицами более эффективной и управляемой.
5. **Обслуживание и резервирование**
   - Можно выполнять операции обслуживания и резервного копирования по отдельным партициям, не блокируя всю таблицу.
6. **Улучшение безопасности данных**
   - Позволяет назначать разные права доступа для разных партиций.
7. **Отказоустойчивость**
   - Проблемы с одной партицией не влияют на остальные, повышая устойчивость системы.
8. **Сокращение времени простоя**
   - Миграции, архивация и другие операции занимают меньше времени, так как применяются только к конкретным партициям.

**Вывод:**  
 Партиционирование особенно полезно для **больших таблиц с историческими или временными данными**, когда важно ускорить доступ, облегчить обслуживание и минимизировать простой базы данных.

## **8.7. Как наиболее оптимально вставить 100000 строк в бд** {#8.7.-как-наиболее-оптимально-вставить-100000-строк-в-бд}

При работе с большими объёмами данных стандартные `INSERT` по одной строке очень медленные. Для массовой вставки данных (Bulk Insert) есть несколько эффективных подходов:

1. **Команда `COPY`**
   - Наиболее быстрый способ вставки больших объёмов данных в PostgreSQL.
   - Работает с файлами CSV или другими форматами.

`COPY your_table`  
`FROM '/path/to/your/data.csv'`  
`DELIMITER ','`  
`CSV HEADER;`

- `your_table` — целевая таблица.
- `/path/to/your/data.csv` — путь к файлу с данными.
- `DELIMITER ','` — разделитель столбцов.
- `CSV HEADER` — первая строка содержит заголовки.

2. **Особенности и преимущества `COPY`**
   - Вставляет тысячи или миллионы строк за один запрос.
   - Минимизирует проверки целостности и индексирования на этапе вставки
   - Значительно быстрее, чем множество отдельных `INSERT`.
3. **Другие подходы для Bulk Insert**
   - Использование множества строк в одном `INSERT` (`INSERT INTO table VALUES (...), (...), (...)`).
   - Использование клиентских библиотек с поддержкой батчевой вставки (`pgx` в Go, `psycopg2.extras.execute_values` в Python и т.д.).
   - Эти методы эффективны, но `COPY` обычно остаётся самым быстрым для больших объёмов данных.

## **8.8. Имеет ли значение порядок полей в составном индексе postgresql** {#8.8.-имеет-ли-значение-порядок-полей-в-составном-индексе-postgresql}

Да, порядок полей в составном индексе имеет значение и напрямую влияет на производительность запросов.

1. **Как работает порядок полей**
   - Составной индекс сортирует данные сначала по первому полю, затем по второму и так далее.
   - Пример: индекс `(A, B)` упорядочивает строки сначала по `A`, затем по `B`. Индекс `(B, A)` будет сортировать сначала по `B`, потом по `A`.
2. **Выбор порядка полей**
   - Порядок должен отражать **наиболее частые фильтры и сортировки в запросах**.
   - Если запросы часто фильтруются по `A` и потом по `B`, оптимален индекс `(A, B)`.
   - Если фильтры и сортировки чаще по `B`, тогда `(B, A)` может быть эффективнее.
3. **Особенности использования операторов сравнения**
   - Порядок полей важен для операторов `BETWEEN`, `>`, `<` и других диапазонных условий.
   - Правильный порядок позволяет PostgreSQL быстрее выполнять запросы, используя индекс максимально эффективно.

**Вывод:**  
 При создании составных индексов важно **анализировать характер запросов** и выбирать порядок полей так, чтобы индекс максимально ускорял фильтрацию и сортировку данных.

# **Специализированные БД** {#специализированные-бд}

## **ClickHouse** {#clickhouse}

ClickHouse — это колоночная база данных с открытым исходным кодом, оптимизированная для **аналитических и OLAP-запросов**. Она предназначена для работы с большими объемами данных и обеспечивает высокую скорость обработки аналитики.

**Основные преимущества ClickHouse:**

1. **Высокая производительность**
   - Способен обрабатывать миллиарды строк данных в секунду.
   - Оптимизирован для сложных агрегирующих запросов.
2. **Колоночное хранение**
   - Данные хранятся по колонкам, что обеспечивает высокую степень сжатия и ускоряет агрегатные запросы.
3. **Масштабируемость**
   - Поддерживает горизонтальное масштабирование через добавление новых узлов.
4. **Поддержка SQL**
   - Легко осваивается разработчиками, знакомыми с SQL.
5. **Репликация и высокая доступность**
   - Позволяет создавать отказоустойчивые кластеры.
6. **Гибкость в аналитике**
   - Поддержка оконных функций, агрегатных функций и пользовательских функций.

**Основные сценарии использования ClickHouse:**

1. **Аналитика в реальном времени**
   - Мониторинг систем, сетевых событий, дашборды BI.
2. **Clickstream анализ**
   - Обработка данных о взаимодействии пользователей: клики, просмотры страниц, действия.
3. **Хранение и анализ исторических данных**
   - Логи событий, временные ряды, данные о транзакциях.
4. **Метрики и мониторинг**
   - Хранение и анализ метрик приложений и инфраструктуры.
5. **Обработка архивных данных и IoT**
   - Архивы данных для последующего анализа, обработка данных с IoT-устройств.

**Примеры использования в индустрии:**

- ClickHouse InDrive — логирование бэкенда.
- ClickHouse Avito — аналитика больших данных.

**Вывод:**  
 ClickHouse — это мощный инструмент для **быстрой аналитики больших объемов данных**, эффективного хранения и масштабирования. Он подходит для OLAP, мониторинга, анализа журналов, метрик, clickstream и исторических данных

## **Redis** {#redis}

Redis (Remote Dictionary Server) — высокопроизводительная, распределённая NoSQL база данных ключ-значение. Он хранит данные в **оперативной памяти**, что обеспечивает невероятно быстрый доступ и высокую пропускную способность.

**Основные преимущества Redis:**

1. **Высокая производительность**
   - Хранение данных в памяти позволяет обрабатывать тысячи запросов в секунду.
2. **Разнообразие типов данных**
   - Поддерживаются строки, списки, множества, хэши, битовые карты, гео-данные, графы.
3. **Надежность и отказоустойчивость**
   - Репликация, журналирование и возможности для отказоустойчивых кластеров.
4. **Гибкость и интеграция**
   - Простая интеграция с различными языками программирования и фреймворками.
5. **Транзакции и атомарность**
   - Поддержка выполнения нескольких операций как одной атомарной транзакции.

**Основные сценарии использования Redis:**

1. **Кэширование**
   - Ускорение доступа к часто запрашиваемым данным, результатам вычислений или БД.
2. **Сессии пользователей**
   - Хранение и управление сессиями веб\-приложений с быстрым доступом и поддержкой TTL.
3. **Очереди и фоновые задачи**
   - Использование Redis как брокера сообщений или очередей для асинхронной обработки задач.
4. **Pub/Sub и события**
   - Подписка на события и уведомления, обработка данных в реальном времени.
5. **Геоинформационные данные**
   - Хранение координат, поиск по радиусу, создание геолокационных приложений.
6. **Аналитика и метрики**
   - Счётчики, временные ряды, данные о транзакциях и действиях пользователей.
7. **Графовые структуры**
   - Построение социальных графов, связей между объектами и пользователями.

**Примеры использования в индустрии:**

- Instagram — Redis используется для хранения лайков и счётчиков активности.
- Общие кейсы: кеширование, очереди задач, аналитика событий, хранение гео-данных.

**Вывод:**  
 Redis — универсальный инструмент для **ускорения приложений, хранения сессий, работы с очередями, аналитики и гео-данных**.

## **Nats** {#nats}

NATS — это высокопроизводительная, легковесная и open-source система сообщений, предназначенная для обмена сообщениями между компонентами распределённых систем. Она идеально подходит для **микросервисной архитектуры, IoT и событийно-ориентированных приложений**.

**Основные преимущества NATS:**

1. **Высокая производительность и низкая латентность**
   - Быстрая передача сообщений с минимальной задержкой.
2. **Легковесность**
   - Низкое потребление ресурсов и небольшой размер, подходит для ограниченных сред.
3. **Простота использования**
   - Лёгкая интеграция с любыми языками и фреймворками.
4. **Масштабируемость и кластеризация**
   - Поддержка горизонтального масштабирования и кластеризации для высоконагруженных приложений.
5. **Отказоустойчивость**
   - Механизмы для обеспечения надежной доставки сообщений.
6. **Безопасность**
   - Поддержка авторизации и шифрования сообщений.

**Основные сценарии использования NATS:**

1. **Микросервисы**
   - Связь и обмен сообщениями между сервисами через Pub/Sub и request-reply модели.
2. **Интернет вещей (IoT)**
   - Передача данных между устройствами и центральными серверами, управление сенсорами и устройствами.
3. **Событийно-ориентированные приложения**
   - Реализация реактивных систем, потоковая обработка событий в реальном времени.
4. **Очереди сообщений**
   - Асинхронная обработка задач и балансировка нагрузки между обработчиками.
5. **Финансовые системы и аналитика**
   - Передача данных в реальном времени для биржевых приложений, систем мониторинга и аналитики.
6. **Мониторинг и логирование**
   - Сбор метрик и событий в распределённых приложениях.

**Примеры использования:**

- IoT и умные города — управление устройствами и сенсорами.
- Финансовые системы — передача событий и данных в реальном времени.
- Тестовые среды и разработка распределённых приложений.

**Вывод:**  
 NATS — это **мощный инструмент для построения распределенных, масштабируемых и отказоустойчивых систем**, где требуется быстрая и надёжная передача сообщений между компонентами.

# Репликация MongoDB {#репликация-mongodb}

## **1\. Replica Set (Репликационный набор)** {#1.-replica-set-(репликационный-набор)}

- **Определение:** группа узлов MongoDB, которые поддерживают одинаковую копию данных.
- Минимальная конфигурация: **Primary \+ Secondary \+ Arbiter (по желанию)**.
- Рекомендуется иметь **нечетное число участников**, чтобы исключить "split-brain" (ситуацию, когда нет кворума).

**Роли узлов:**

- **Primary**
  - принимает все операции записи;
  - ведет **oplog** — журнал изменений;
  - отвечает на запросы чтения (по умолчанию).
- **Secondary**
  - реплицирует данные с Primary;
  - можно использовать для чтения (в зависимости от **Read Preference**);
  - может стать новым Primary при failover.
- **Arbiter**
  - не хранит данные, участвует только в голосовании;
  - нужен для обеспечения кворума в кластере с четным числом узлов.

## **2\. Oplog (операционный журнал)** {#2.-oplog-(операционный-журнал)}

- **Формат:** capped collection (`local.oplog.rs`), хранит последовательность операций в порядке их выполнения.
- **Тип операций:** `insert`, `update`, `delete`, DDL (например, создание коллекции).
- Secondary узлы читают oplog и **применяют операции в том же порядке**, чтобы синхронизироваться с Primary.
- Объем oplog ограничен → старые записи затираются, что важно для disaster recovery.

## **3\. Механизм репликации** {#3.-механизм-репликации}

1. Клиент выполняет запись на **Primary**.
2. Primary подтверждает запись и фиксирует её в **oplog**.
3. Secondary через **oplog tailing** (stream-подписку) считывают новые операции.
4. Secondary применяют изменения у себя в том же порядке.

Репликация **асинхронная**, но можно добиться квазисинхронности через `Write Concern`.

## **4\. Failover (автоматическое переключение)** {#4.-failover-(автоматическое-переключение)}

- Если Primary недоступен:

  1. Узлы Replica Set начинают процедуру **выборов (election)**.
  2. Каждый Secondary может предложить себя как нового Primary.
  3. Узлы голосуют, и тот, кто набирает **большинство голосов**, становится новым Primary.
  4. Клиентские драйверы автоматически перенаправляют запросы на нового Primary.

⚡ Среднее время failover — несколько секунд (обычно 2–10 сек).

## **5\. Write Concern (подтверждение записи)** {#5.-write-concern-(подтверждение-записи)}

Управляет тем, сколько узлов должны подтвердить операцию:

- `w:1` — только Primary;
- `w:majority` — большинство узлов Replica Set;
- `w:n` — конкретное число узлов.

Примеры:

`db.orders.insertOne({ item: "book" }, { writeConcern: { w: "majority", j: true } })`

- `w: "majority"` — запись считается успешной только если большинство узлов её применили.

- `j: true` — запись зафиксирована в журнале (journal), то есть переживет перезапуск.

## **6\. Read Preference (предпочтения чтения)** {#6.-read-preference-(предпочтения-чтения)}

Определяет, с какого узла читать:

- `primary` (по умолчанию) — только с Primary.
- `primaryPreferred` — сначала с Primary, но можно с Secondary, если Primary недоступен.
- `secondary` — только с Secondary.
- `secondaryPreferred` — в приоритете Secondary.
- `nearest` — ближайший по сетевой задержке узел.

⚠️ Важно: чтение с Secondary может возвращать "устаревшие" данные из\-за **replication lag**.

## **7\. Replication Lag (задержка репликации)** {#7.-replication-lag-(задержка-репликации)}

- Время между записью на Primary и применением её на Secondary.
- Причины:
  - слабое «железо» у Secondary;
  - перегрузка по запросам;
  - большие write-нагрузки.
- Последствия:
  - при чтении с Secondary можно получить устаревшие данные;
  - при failover данные могут потеряться, если новый Primary не успел догнать старый.

## **8\. Arbiter (Арбитр)** {#8.-arbiter-(арбитр)}

- Узел без данных, только для голосования.
- Используется для кворума, но снижает отказоустойчивость (так как нет дополнительных копий данных)
- В проде стараются заменять Arbiter на полноценный Secondary.

## **9\. Связь с Шардированием** {#9.-связь-с-шардированием}

- В MongoDB шардирование и репликация **работают вместе**:
  - **Шардирование** — распределяет данные по множеству шардов (горизонтальное масштабирование).
  - Каждый **шард \= Replica Set**, чтобы внутри шарда были отказоустойчивость и консистентность.

## **10\. Особенности и best practices** {#10.-особенности-и-best-practices}

- Держать **нечетное число узлов** (3, 5, 7).
- Следить за размером **oplog** (иначе отставшие Secondary не смогут догнать Primary → придется пересинхронизировать с нуля).
- Использовать `writeConcern: majority` для критичных данных.
- Для балансировки чтения → подключать **Read Preference** с Secondary.
- Геораспределение: можно размещать узлы в разных датацентрах, чтобы выдерживать сбои ЦОД.

✅ **Вывод:**  
 Репликация в MongoDB строится вокруг **Replica Set**, где один Primary фиксирует все изменения в **oplog**, а Secondary повторяют эти операции. Механизм failover обеспечивает автоматическую замену Primary. Поведение при записи и чтении можно тонко настраивать через **Write Concern** и **Read Preference**. В сочетании с шардированием репликация обеспечивает **масштабируемость \+ отказоустойчивость \+ доступность**.

# **Логирование и очереди** {#логирование-и-очереди}

## **ELK стек** {#elk-стек}

**ELK** \= **Elasticsearch \+ Logstash \+ Kibana**  
 Это стандартный стек для работы с логами: **сбор → обработка → хранение → поиск → визуализация**.  
 Используется для мониторинга, отладки и аналитики в распределённых системах.

## **🔹 1\. Elasticsearch** {#🔹-1.-elasticsearch}

- Это **распределённый поисковый и аналитический движок**.
- Хранит данные в виде **индексов** (похоже на таблицы в SQL).
- Оптимизирован для **фулл-текста, поиска по полям и агрегаций**.
- Основные фичи:
  - Горизонтальное масштабирование (кластер из нод).
  - Высокая скорость поиска и фильтрации (Lucene под капотом).
  - Поддержка **структурированных и неструктурированных данных**.

👉 В реальном проде: туда мы складываем **логи из микросервисов** (Go, Python, Node), метрики и события.

## **🔹 2\. Logstash** {#🔹-2.-logstash}

- Это **ETL-пайплайн для данных**:
  - **Input** (откуда данные приходят — Kafka, TCP, файлы, Beats).
  - **Filter** (трансформация: парсинг JSON, grok-шаблоны, нормализация).
  - **Output** (куда отправить — Elasticsearch, S3, Kafka).
- Очень мощный, но тяжеловесный (Java → потребляет ресурсы).

👉 На проектах часто заменяют Logstash на **Filebeat / Fluentd**, если нужен лёгкий агент для доставки логов.

## **🔹 3\. Kibana** {#🔹-3.-kibana}

- Это **UI для Elasticsearch**.
- Используется для:
  - построения дашбордов;
  - визуализации метрик;
  - поиска логов в реальном времени (через Lucene-синтаксис или KQL).
- Удобен для DevOps, SRE и разработчиков: можно сразу посмотреть, что пошло не так.

👉 В проде мы часто делаем **дашборды по ошибкам Go-сервисов**, фильтруем по `service_name`, `env`, `trace_id`.

## **🔹 4\. Где применяется ELK** {#🔹-4.-где-применяется-elk}

- **Централизованное логирование**: сбор логов со всех сервисов (например, микросервисная архитектура на Go).
- **Мониторинг и алертинг**: анализ метрик и ошибок.
- **Security / SIEM**: хранение и анализ событий безопасности.
- **Бизнес-аналитика**: иногда используют для быстрых дешёвых агрегаций по событиям.

## **🔹 5\. Боли и нюансы из реального опыта** {#🔹-5.-боли-и-нюансы-из-реального-опыта}

- **Elasticsearch прожорливый**: требует много памяти и быстрых дисков (SSD).
- **Logstash тяжёлый**: на высоких нагрузках его меняют на **Beats** или Kafka \+ Fluentd.
- **Хранение логов дорогое**: обычно держат 7–30 дней, дальше архивируют в S3.
- **Сложность в поддержке**: нужен отдельный DevOps/infra-энг для кластера.

## **🔹 6\. Go-разработчику это зачем?** {#🔹-6.-go-разработчику-это-зачем?}

- В проде сервисы на Go обычно пишут логи в **stdout** в формате JSON.
- Далее:
  - Filebeat/FluentBit → пересылают в Logstash/Kafka → Elasticsearch.
  - Kibana → для поиска по `trace_id`/`request_id`.
- Это даёт:
  - Быструю диагностику проблем (ошибки, latency, паники).
  - Возможность привязывать логи к метрикам (через Grafana \+ ELK).

✅ **Вывод:**  
 ELK стек — это **стандарт де\-факто** для логирования и аналитики в распределённых системах. Он даёт централизованный сбор логов, быстрый поиск и удобную визуализацию, но требует ресурсов и грамотной эксплуатации. В Go-проектах его чаще всего используют вместе с **Beats (Filebeat)** или Kafka для доставки логов.

# **Очереди** {#очереди}

## **RabbitMQ** {#rabbitmq}

RabbitMQ — это брокер сообщений, основной компонент которого **очередь (Queue)**. Очередь отвечает за временное хранение сообщений и их доставку потребителям. Использование очередей позволяет:

- Обеспечить **асинхронный обмен данными** между сервисами.
- Гарантировать **надёжную доставку сообщений**, даже при сбоях.
- Масштабировать обработку сообщений через **несколько потребителей**.

## **🔹 1\. Основные участники работы с очередями** {#🔹-1.-основные-участники-работы-с-очередями}

1. **Publisher (Издатель)**  
   Отправляет сообщение в **exchange**. В Go это обычно клиент `streadway/amqp` или `rabbitmq/amqp091-go`.

2. **Exchange (Обменник)**  
    Решает, **куда доставить сообщение**. Типы маршрутизации:
   - **Direct** — сообщение идёт в очередь с точным совпадением ключа.
   - **Fanout** — сообщение отправляется во все привязанные очереди (broadcast).
   - **Topic** — маршрутизация по шаблону ключа (`order.created.*`).
   - **Headers** — маршрутизация на основе заголовков.
3. **Queue (Очередь)**
   - Хранит сообщения до их обработки.
   - Может быть: durable (на диск), exclusive (только для одного consumer), auto-delete (удаляется, если нет потребителей).
   - Поддерживает **одного или нескольких потребителей**, что позволяет масштабировать обработку.
4. **Consumer (Потребитель)**

   - Получает сообщение из очереди и выполняет обработку.

   - После успешной обработки отправляет **ack**, чтобы RabbitMQ удалил сообщение из очереди.

## **🔹 2\. Стратегия PUSH и нагрузка** {#🔹-2.-стратегия-push-и-нагрузка}

RabbitMQ работает по **push-модели**: брокер активно отправляет сообщения потребителям.

**Плюсы:**

- Быстрая доставка сообщений.
- Подходит для систем с небольшими задержками.

**Минусы:**

- Если потребитель медленный, очередь растёт → нагрузка на брокер увеличивается.
- Нужно контролировать **prefetch** (QoS), чтобы ограничить количество сообщений, отправляемых на одного потребителя.

## **🔹 3\. Надежность и отказоустойчивость** {#🔹-3.-надежность-и-отказоустойчивость}

- **Durable очереди** и **persistent сообщения** → сохраняются на диск, не теряются при перезапуске брокера.
- **Replicated queues (кластеризация)** → зеркалирование очередей между нодами.
- **Dead Letter Queues (DLQ)** → отдельные очереди для "битых" сообщений, которые не удалось обработать.

## **🔹 4\. Расширенные возможности очередей** {#🔹-4.-расширенные-возможности-очередей}

- **Многопользовательский доступ** → разные сервисы могут читать одну очередь с контрольными правами.
- **Маршрутизация сообщений** → гибкость: direct, topic, fanout, headers.
- **Масштабирование обработки** → несколько консьюмеров на одну очередь для параллельной обработки.

## **🔹 5\. Работа с очередями в Go (упрощённый пример)** {#🔹-5.-работа-с-очередями-в-go-(упрощённый-пример)}

`conn, _ := amqp.Dial("amqp://guest:guest@localhost:5672/")`  
`ch, _ := conn.Channel()`  
`q, _ := ch.QueueDeclare("tasks", true, false, false, false, nil)`  
`msgs, _ := ch.Consume(q.Name, "", false, false, false, false, nil)`

`for msg := range msgs {`  
 `go func(m amqp.Delivery) {`  
 `fmt.Println("Received:", string(m.Body))`  
 `// обработка задачи`  
 `m.Ack(false)`  
 `}(msg)`  
`}`

- Здесь создаётся durable очередь `tasks`.
- Сообщения обрабатываются параллельно через **goroutines**.
- После успешной обработки отправляется **ack**.

## **Kafka** {#kafka}

Kafka — это распределённая платформа для обработки потоков данных (event streaming platform). Основное предназначение: **масштабируемая, надёжная доставка и обработка сообщений в реальном времени**.

## **🔹 1\. Основные компоненты Kafka** {#🔹-1.-основные-компоненты-kafka}

1. **Brokers (Брокеры)**
   - Серверы Kafka, объединённые в кластер.
   - Хранят данные (сообщения) и обслуживают запросы от производителей (Producers) и потребителей (Consumers).
   - Масштабируются горизонтально: добавление новых брокеров увеличивает производительность и отказоустойчивость.
2. **Topics (Темы)**
   - Сообщения в Kafka организованы по темам.
   - Каждая тема — логическая категория сообщений, например: `orders`, `user_events`.
3. **Partitions (Партиции)**
   - Каждая тема разбивается на несколько партиций.
   - Партиции позволяют **параллельную обработку сообщений** и **масштабирование потребителей**.
   - Партиции **реплицируются** на разных брокерах для отказоустойчивости.
4. **Producers (Производители)**
   - Отправляют сообщения в темы.
   - Могут указывать партицию или использовать ключ для определения, в какую партицию попадёт сообщение.
5. **Consumers (Потребители)**
   - Читают сообщения из партиций.
   - Работают в составе **consumer groups**, что позволяет распределять обработку сообщений между несколькими экземплярами приложения.
6. **Retention (Срок хранения сообщений)**
   - Kafka хранит сообщения **в течение заданного периода времени** или до достижения лимита объёма.
   - Потребители могут читать данные **с разной скоростью**, что делает Kafka более гибкой, чем push-брокеры.

## **🔹 2\. Основные преимущества Kafka** {#🔹-2.-основные-преимущества-kafka}

- **Высокая производительность**: обработка миллионов сообщений в секунду на одном сервере.
- **Распределённость**: легко масштабируется горизонтально, партиции реплицируются для отказоустойчивости.
- **Устойчивость к сбоям**: данные сохраняются на диск и дублируются между брокерами.
- **Гарантии доставки**: поддержка `at-most-once`, `at-least-once` и `exactly-once` delivery.
- **Гибкость**: подходит для потоковой аналитики, событийной обработки, микросервисной архитектуры.
- **PULL-стратегия**: клиенты сами читают сообщения, что предотвращает перегрузку.

## **🔹 3\. Сценарии использования Kafka** {#🔹-3.-сценарии-использования-kafka}

1. **Потоковая аналитика**: обработка логов, кликов, событий в реальном времени.
2. **Микросервисы**: обмен событиями между сервисами с гарантией доставки.
3. **ETL и интеграция данных**: сбор данных с разных систем и передача их в хранилища.
4. **Историческое хранение событий**: Kafka хранит данные долго, что удобно для аналитики и восстановления состояния.
5. **Мониторинг и алертинг**: события от приложений, инфраструктуры или IoT устройств.

## **🔹 4\. Отличие Kafka от RabbitMQ** {#🔹-4.-отличие-kafka-от-rabbitmq}

| Параметр           | Kafka                               | RabbitMQ                           |
| ------------------ | ----------------------------------- | ---------------------------------- |
| Модель доставки    | PULL (потребитель сам читает)       | PUSH (брокер отправляет сообщения) |
| Хранение сообщений | Долгосрочное                        | Обычно краткосрочное               |
| Масштабирование    | Партиции, горизонтально             | Очереди, многопотребители          |
| Подходит для       | Потоковая аналитика, event sourcing | Асинхронные задачи, очереди задач  |
| Гарантия порядка   | На уровне партиции                  | На уровне очереди                  |

## **🔹 5\. Работа с Kafka в Go (упрощённо)** {#🔹-5.-работа-с-kafka-в-go-(упрощённо)}

`package main`

`import (`  
 `"github.com/segmentio/kafka-go"`  
 `"context"`  
 `"log"`  
`)`

`func main() {`  
 `writer := kafka.NewWriter(kafka.WriterConfig{`  
 `Brokers: []string{"localhost:9092"},`  
 `Topic:   "orders",`  
 `})`

    `err := writer.WriteMessages(context.Background(),`
        `kafka.Message{Key: []byte("1"), Value: []byte("Order #1")},`
        `kafka.Message{Key: []byte("2"), Value: []byte("Order #2")},`
    `)`
    `if err != nil {`
        `log.Fatal(err)`
    `}`

    `reader := kafka.NewReader(kafka.ReaderConfig{`
        `Brokers: []string{"localhost:9092"},`
        `Topic:   "orders",`
        `GroupID: "order-processors",`
    `})`

    `for {`
        `m, err := reader.ReadMessage(context.Background())`
        `if err != nil {`
            `log.Fatal(err)`
        `}`
        `log.Printf("Received: %s", string(m.Value))`
    `}`

`}`

- **Writer** — отправляет сообщения в тему `orders`.
- **Reader** — читает сообщения в составе consumer group `order-processors`.
- Параллельная обработка достигается через **партиции и несколько консьюмеров**.

[image1]: data:image/png;base64,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4Db9/AoAoL/WwAUADIfABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCFwAqITABYBKCNwF3Xb7HZPX33hzphyf2dvbmzz73OmZcuAwaw3cCx/uTZ68+uRM+ar8xT9enPzpX36yLy/v6q+O/6Gd//r4/2aWL+ve+x6YBkouL7nzrns61x2CQu7ITbfOlJuWfbS7u//62utumFz1xWumurbR1fET3xmkndp0fjZxvzF+rYF7duds9cD9p53fTp/r8cy7/ztTZx61Ibl8KOrVKqRyeZMxB67qlnqh89roalODS9dY32ByObCsYuBePH9x8tTNpyYPX/7QAVr22rFXpz1fP1c994S9zgt3H7yJvb6Wq+28PYuBq16qe6d/9tef7ofvkb/5rNeqerFHHJeXAlfraJnqqj2Xx95wbCeWe59EAaqeW27fvUQHmnrBLjOHm5a7zOHndl0eQzq2NS+854VlDFxtLwdu3Ifc84374fVUf2fn1LRMH0R5mEWvc1nJB289M3nwS5dMfbr38bTsxcePTh5/4MrJiaOXTctVR+U//Mb1U9/8yqXT8vPn3puWv/Xi8f02tI7bVhvn3v/FtFzr5G1nBC5WpRi4VurhtgWu6qv8sSse2X+u8N0984evsG1igMbQbApc1Tt/4bNQVn09Vz3Vdz23EQM8Pne9H738PweCWK/9GIc3FFg5pPQ6fk2Pcg839/ocgKrncNNrh7oetSy326RP4EoO1bY2fCyxl+9hA3/I5H1VeT5fmYI0BqECUqGrwI1B63KFrYPWr7VcbcRQdhDHoFW5A71J33MOdDVo4LqOw1dB+0SPIQn3cN0bdXlT4MY6DtzYntaJQxSxJzsvcPU81nd5KXAl9/wsB26pB6l1VE+BFbcTe6LuQebtZk1hWWo30rbjUENuQyGb91vl2jevVxpu6RK4DlBzcCpwY0811lf4xjIHtF8rbP1abTh8uyBwsSqjDFw9j1/jFw1cvVZvNrehcHXgOlDjcrfv53E7TUMKlkO3FLilmzkHbl7P6877el4Ky6gpcLWe2y610TQ0kAP3yI23dFov8hBBLl82cDXEoOd9A5chBaxK78AVj8m+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
[image2]: data:image/png;base64,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
[image3]: data:image/png;base64,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
[image4]: data:image/png;base64,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
