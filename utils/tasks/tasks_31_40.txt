/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.8. Что такое GROUP BY?",
  "answer": "`GROUP BY` группирует строки по значениям одного или нескольких столбцов, что позволяет применять агрегирующие функции (`SUM`, `COUNT`, `AVG` и др.) к каждой группе отдельно. Используется, когда нужно свести данные к более компактному виду или посчитать агрегаты по категориям.\nПример:\n`SELECT department, COUNT(*)`\n`FROM employees`\n`GROUP BY department;`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.9. Что такое DISTINCT?",
  "answer": "`DISTINCT` удаляет дублирующиеся строки из результата запроса. Часто используется, когда необходимо получить список уникальных значений одного или нескольких столбцов. Важно понимать, что `DISTINCT` применяется ко всем выбранным столбцам вместе, а не по отдельности.\nПример:\n`SELECT DISTINCT department`\n`FROM employees;`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.10. Что такое LIMIT?",
  "answer": "`LIMIT` ограничивает количество возвращаемых строк. Полезен для пагинации или когда нужно получить лишь часть данных (например, топ N записей). Работает в большинстве SQL-систем, но синтаксис может немного различаться.\nПример:\n`SELECT *`\n`FROM products`\n`LIMIT 10;`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.11. Что такое EXISTS?",
  "answer": "`EXISTS` проверяет, существует ли хотя бы одна строка, удовлетворяющая условию подзапроса. Возвращает `TRUE`, если подзапрос возвращает хотя бы одну строку, и `FALSE` — если нет. Это эффективный способ фильтровать данные, когда нас интересует не конкретное значение, а факт существования записи.\nПример:\n`SELECT employee_name`\n`FROM employees`\n`WHERE EXISTS (`\n`SELECT 1`\n`FROM orders`\n`WHERE orders.employee_id = employees.employee_id`\n`);`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.12. Расскажите про оператор IN,",
  "answer": "**IN**\n`IN` используется для проверки, содержится ли значение столбца в заданном множестве значений или результатах подзапроса. Это удобная альтернатива множественным `OR`\\-условиям и помогает сделать запрос более читаемым и оптимизированным.\nПример:\n`SELECT *`\n`FROM products`\n`WHERE category_id IN (1, 2, 3);`\nВ реальных кейсах часто используется для фильтрации по списку статусов, категорий или ID, когда заранее известен набор значений."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.13. Расскажите про оператор BETWEEN,",
  "answer": "**BETWEEN**\n`BETWEEN` проверяет, находится ли значение столбца в определённом диапазоне, включительно. Чаще всего применяется для числовых, денежных или датовых полей.\nПример:\n`SELECT *`\n`FROM sales`\n`WHERE sale_amount BETWEEN 1000 AND 5000;`\nВажно помнить, что `BETWEEN a AND b` включает границы `a` и `b`. На практике это удобно для выборки за период времени или по диапазону сумм.\n**3.14. Расскажите про оператор LIKE.**\n**LIKE**\n`LIKE` используется для поиска строк, соответствующих определённому шаблону. Позволяет использовать символы подстановки:\n- `%` — любое количество символов, включая ноль\n- `_` — ровно один символ\nПример:\n`SELECT *`\n`FROM customers`\n`WHERE last_name LIKE 'Smith%';`\nНа практике `LIKE` полезен для поиска по частям строк: например, поиск клиентов по первой букве фамилии или товара по части названия. Для больших таблиц стоит учитывать производительность и при необходимости использовать полнотекстовый поиск или индексы."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.15. Что делает оператор MERGE? Какие у него есть ограничения?",
  "answer": "**MERGE**\n`MERGE` (часто называют UPSERT или `ON DUPLICATE KEY UPDATE` в некоторых СУБД) позволяет выполнить **вставку или обновление записи** в таблице в зависимости от того, существует ли она уже. Это объединяет логику `INSERT` и `UPDATE` в одном операторе, что упрощает работу с дубликатами и синхронизацией данных.\n**Принцип работы:**\n1. **INSERT** — если запись с заданным ключом отсутствует, создаётся новая.\n2. **UPDATE** — если запись с ключом уже существует, она обновляется новыми значениями.\nПример (синтаксис для SQL Server / Oracle):\n`MERGE INTO employees AS target`\n`USING (SELECT 1 AS employee_id, 'John Doe' AS name) AS source`\n`ON target.employee_id = source.employee_id`\n`WHEN MATCHED THEN`\n`UPDATE SET name = source.name`\n`WHEN NOT MATCHED THEN`\n`INSERT (employee_id, name) VALUES (source.employee_id, source.name);`\n**Практическое использование:**\n- Синхронизация данных между таблицами или источниками.\n- Упрощение обработки «добавить или обновить».\n- Эффективная работа с ETL и массовыми обновлениями данных.\n**Ограничения и нюансы:**\n1. **Не является стандартным SQL** — синтаксис и поддержка зависят от СУБД.\n- MySQL: `INSERT ... ON DUPLICATE KEY UPDATE`\n- PostgreSQL: `INSERT ... ON CONFLICT DO UPDATE`\n2. **Производительность** — массовые MERGE могут быть медленными на больших таблицах без правильных индексов.\n3. **Триггеры и ограничения** — поведение может отличаться, особенно с внешними ключами и ограничениями уникальности.\n4. **Одновременные операции** — при высокой конкуренции нужно быть осторожным с блокировками и гонками данных."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.16. Какие агрегатные функции вы знаете?",
  "answer": "**Агрегатные функции SQL**\nАгрегатные функции позволяют выполнять вычисления над набором строк и получать одно итоговое значение для группы. Они часто используются вместе с `GROUP BY` для анализа данных.\n**Основные функции:**\n- `COUNT()` — считает количество строк в наборе результатов. Можно использовать `COUNT(DISTINCT column)` для подсчёта уникальных значений.\n- `SUM()` — суммирует числовые значения столбца.\n- `AVG()` — вычисляет среднее значение числового столбца.\n- `MIN()` / `MAX()` — возвращают минимальное и максимальное значение соответственно.\n**Работа со строками:**\n- `GROUP_CONCAT()` / `STRING_AGG()` — объединяет строки в одну, используя разделитель. Отлично подходит для создания списков в одной колонке.\n**Статистические функции:**\n- `STDDEV()` / `STDEV()` — стандартное отклонение.\n- `VARIANCE()` — дисперсия.\n- `CORR()` — коэффициент корреляции между двумя числовыми столбцами.\n- `COVAR_POP()` / `COVAR_SAMP()` — популяционная и выборочная ковариация.\n**Аналитические функции (window functions):**\n- `FIRST()` / `LAST()` — первое и последнее значение в группе.\n- `PERCENTILE_CONT()` / `PERCENTILE_DISC()` — вычисляют перцентили.\n- `CUME_DIST()` — накопительное распределение значений.\n- `RANK()` / `DENSE_RANK()` — ранжируют значения в упорядоченном наборе данных.\n**Агрегация в массивы и JSON:**\n- `ARRAY_AGG()` / `JSON_AGG()` — собирают значения в массив или JSON-объект. Полезно для построения вложенных структур данных при аналитике или API.\n**Практические советы на интервью:**\n1. Многие функции доступны не во всех СУБД, поэтому важно знать аналоги для PostgreSQL, MySQL, SQL Server и Oracle.\n2. Агрегатные функции можно комбинировать с `GROUP BY` и фильтровать с `HAVING`.\n3. Window-функции (`RANK`, `CUME_DIST`) удобны для аналитики без потери исходных строк.\n4. Для больших таблиц стоит обращать внимание на индексы и группировки — некоторые агрегаты (особенно `DISTINCT`, `GROUP_CONCAT`) могут быть ресурсоемкими."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.17. Что такое ограничения (constraints)? Какие вы знаете?",
  "answer": "Ограничения (constraints) в SQL \\- это правила, устанавливаемые на столбцы таблицы, которые определяют, какие значения могут быть вставлены, обновлены или удалены в таблице.\nОсновные типы ограничений:\n1. **Primary Key** — определяет уникальный идентификатор строки. Нельзя вставить дубликат и нельзя оставить `NULL`.\n2. **Unique** — похож на первичный ключ, но может применяться к нескольким колонкам, и в отличие от PK может допускать `NULL`.\n3. **Foreign Key** — обеспечивает ссылочную целостность между таблицами. Например, нельзя вставить заказ на несуществующего пользователя. Также можно задать поведение при удалении или обновлении (`CASCADE`, `SET NULL` и т. д.).\n4. **Check** — кастомные условия на значения в колонке, например, чтобы возраст был больше 0 или дата окончания договора не раньше даты начала.\n5. **Default** — задаёт значение по умолчанию для колонки, если при вставке оно не указано.\n6. **Ограничения на удаление/обновление (ON DELETE / ON UPDATE)** — определяют поведение при изменении связанных записей: каскадное удаление, установка `NULL`, запрет и т. д.\nНа практике я стараюсь использовать ограничения максимально, потому что они убирают часть бизнес-логики из приложения и гарантируют защиту на уровне данных. Даже если где\\-то в коде закралась ошибка, constraint не даст положить мусор в базу."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.18. Что такое суррогатные ключи?",
  "answer": "Суррогатный ключ — это искусственный первичный ключ, который не несёт бизнес-смысла и существует только для обеспечения уникальности строки. Чаще всего это авто_инкрементируемое число или UUID, которое генерируется базой при вставке записи.\nОсновные моменты:\n- **Уникальность:** каждый суррогатный ключ гарантированно уникален.\n- **Независимость от данных:** он не зависит от бизнес-атрибутов и не меняется при изменении данных.\n- **Производительность:** сравнивать и индексировать целочисленный ключ проще и быстрее, чем, например, составной натуральный ключ из нескольких колонок.\n- **Прозрачность:** для пользователей и бизнес-логики этот ключ, как правило, скрыт. Никто не будет опираться на `id` в реальном бизнес-контексте, он нужен только для связей и внутренней целостности.\nКлассический пример — поле `id SERIAL` в PostgreSQL или `AUTO_INCREMENT` в MySQL.\nОбычно суррогатные ключи используют вместе с естественными ключами (например, email пользователя или артикул товара). Естественный ключ полезен для бизнес-логики, а суррогатный — для ссылочной целостности и стабильности схемы. Такой подход упрощает жизнь при рефакторинге: бизнес-атрибуты могут измениться, а суррогатный ключ останется тем же самым."
}
