/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2.12. Что такое шардинг и репликация?",
  "answer": "**Шардинг (Sharding)**\n\nШардинг — это метод **горизонтального масштабирования**, когда данные делятся на независимые сегменты (**шарды**) и распределяются по разным серверам.\n\n- Каждый шард хранит только часть данных и обрабатывает только свою нагрузку.\n\n- Это позволяет системе обрабатывать большие объемы данных и писать/читать параллельно.\n\nМинусы: Трудности с глобальными запросами (`JOIN` или агрегации по всем шардам).\n\n**Репликация (Replication)**\n\nРепликация — это **создание копий данных** на нескольких серверах.\n\n- Обычно есть **primary** (мастер) и несколько **replica** (слейвов).\n\n- Primary принимает записи, реплики синхронно или асинхронно копируют изменения и обслуживают запросы на чтение.\n\nМинусы: Задержка репликации (особенно в асинхронных схемах).\n\n**Шардинг и репликация используют вместе**:\n\n- Шардинг — для горизонтального масштабирования (делим данные на сегменты).\n\n- Репликация — для отказоустойчивости и масштабирования чтения.\n\n**Пример:**\n\n- Пользователи делятся по регионам → каждый регион хранится в отдельном шарде.\n\n- В каждом шарде — одна основная база \\+ несколько реплик для чтения и резервирования."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2.13. Какие типы репликации существуют в PostgreSQL?",
  "answer": "1\\. Физическая (Streaming Replication, Master-Slave)\n\n- **Классический вариант:** есть один **primary** (мастер) и несколько **standby** (реплик).\n\n- Реплики получают WAL-записи (журнал транзакций) и применяют их для синхронизации.\n\n- Реплики доступны только для **чтения**.\n\n**Плюсы:** высокая производительность, простая настройка.\n\n**Минусы:** нагрузку на запись нельзя распределить.\n\n2\\. Логическая репликация (Logical Replication)\n\n- Позволяет реплицировать **не всю БД, а выбранные таблицы/колонки**.\n\n- Работает на уровне изменений данных (INSERT, UPDATE, DELETE).\n\n- Подходит для интеграции, аналитики, миграций и построения event-driven систем.\n\n**Плюсы:** гибкость (можно фильтровать данные).\n\n**Минусы:** медленнее физической, больше накладных расходов.\n\n3\\. Мастер-мастер репликация (Multi-Master, Bi-Directional Replication, BDR)\n\n- Несколько узлов работают как мастера: принимают и записи, и чтение.\n\n- Узлы синхронизируются между собой (обычно через логическую репликацию).\n\n- Используется для географически распределённых систем.\n\n**Плюсы:** распределение нагрузки на запись.\n\n**Минусы:** сложная настройка, конфликты при синхронизации.\n\n4\\. Каскадная репликация (Cascading Replication)\n\n- Реплика может сама быть источником для других реплик.\n\n- Полезно, когда у вас десятки узлов, и не хочется перегружать мастер.\n\n5\\. Асинхронная vs. Синхронная\n\n- **Асинхронная (по умолчанию):** мастер не ждёт подтверждения от реплик → быстрее, но возможна потеря данных при падении мастера.\n\n- **Синхронная:** мастер ждёт подтверждения от хотя бы одной реплики → данные гарантированно не теряются, но выше задержки записи."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2.14. По какому принципу могут данные шардироваться?",
  "answer": "**1\\. Горизонтальное шардирование (Horizontal Sharding)**\n\n- Данные делятся по **строкам**.\n\n- Каждая таблица в шарде содержит одинаковую схему, но разные подмножества строк.\n\nПример: пользователи из Европы в одном шарде, из Азии — в другом.\n\n❌ Минусы: сложность при глобальных запросах (JOIN по всем шардам).\n\n**2\\. Вертикальное шардирование (Vertical Sharding)**\n\n- Таблица разбивается по **столбцам**.\n\n- Каждый шард хранит только часть атрибутов объекта.\n\nПример: в одном шарде — «основные данные пользователя» (id, name, email), в другом — «редко используемые данные» (preferences, logs).\n\n❌ Минусы: чаще нужны JOIN между шардами.\n\n**3\\. Диапазонное шардирование (Range Sharding)**\n\n- Деление по диапазону значений ключа.\n\nПример: даты заказов → `2020–2021` в одном шарде, `2022–2023` в другом.\n\n❌ Минусы: при «горячем диапазоне» один шард может перегружаться.\n\n**4\\. Хэш-шардирование (Hash Sharding)**\n\n- Используется хэш-функция для ключа (например, `user_id % N`).\n\nПример: если у нас 4 шарда, пользователь с id=123 попадёт в шард `123 % 4 = 3`.\n\n❌ Минусы: сложно делать range-запросы.\n\n**5\\. По типу (Type Sharding)**\n\n- Данные делятся по сущностям или категориям.\n\nПример: одни шарды для пользователей, другие — для продуктов, третьи — для логов.\n\n❌ Минусы: возможны перекосы нагрузки (например, «шард пользователей» перегружен).\n\n**6\\. Смешанное (Composite Sharding)**\n\n- Комбинация методов."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.1. Что такое SQL?",
  "answer": "SQL (Structured Query Language) \\--- декларативный язык структурированных запросов. Это язык программирования, который используется для создания, изменения и управления данными в реляционных базах данных."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.2. Синтаксис языка SQL, Что такое DDL, DML, TCL, DCL?",
  "answer": "Вот основные элементы синтаксиса SQL и практические навыки, связанные с ним:\n\n1. Операторы DDL\n\n(Data Definition Language \\- Язык Определения Данных):\n\n- CREATE TABLE: Создание новой таблицы.\n\n- ALTER TABLE: Изменение структуры существующей таблицы.\n\n- DROP TABLE: Удаление таблицы.\n\n- CREATE DATABASE: Создание новой базы данных.\n\n- ALTER DATABASE: Изменение базы данных.\n\n- DROP DATABASE: Удаление базы данных.\n\n2. Операторы DML\n\n(Data Manipulation Language \\- Язык Манипуляции Данными)\n\n- SELECT: Извлечение данных из таблицы.\n\n- INSERT: Вставка новых данных в таблицу.\n\n- UPDATE: Обновление существующих данных в таблице.\n\n- DELETE: Удаление данных из таблицы.\n\n3. Операторы DCL\n\n(Data Control Language \\- Язык Контроля Доступа к Данным):\n\n- GRANT: Предоставление прав доступа к данным другим пользователям\n\nили ролям.\n\n- REVOKE: Отзыв прав доступа к данным.\n\n4. Операторы TCL\n\n(Transaction Control Language \\- Язык Управления Транзакциями):\n\n- COMMIT: Завершение текущей транзакции и сохранение изменений в базе данных.\n\n- ROLLBACK: Откат текущей транзакции и отмена всех изменений.\n\n- SAVEPOINT: Создание точки сохранения внутри транзакции.\n\n5. Операторы фильтрации и сортировки:\n\n- WHERE: Фильтрация результатов запроса на основе условий.\n\n- ORDER BY: Сортировка результатов по одному или нескольким столбцам.\n\n- GROUP BY: Группировка данных по одному или нескольким столбцам.\n\n- HAVING: Фильтрация результатов группировки.\n\n6. Функции агрегации:\n\n- COUNT(): Подсчет количества строк.\n\n- SUM(): Суммирование числовых значений.\n\n- AVG(): Вычисление среднего значения.\n\n- MAX(): Поиск максимального значения.\n\n- MIN(): Поиск минимального значения.\n\n7. Соединения таблиц:\n\n- INNER JOIN: Внутреннее соединение двух таблиц на основе совпадающих значений.\n\n- LEFT JOIN: Левое соединение, включая все строки из первой таблицы и соответствующие строки из второй таблицы.\n\n- RIGHT JOIN: Правое соединение, включая все строки из второй таблицы и соответствующие строки из первой таблицы.\n\n- FULL OUTER JOIN: Полное внешнее соединение, включая все строки из обеих таблиц.\n\n8. Подзапросы:\n\n- Вложенные SELECT запросы, используемые для выполнения запросов внутри других запросов."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.3. Нюансы работы с NULL в SQL. Как проверить поле на NULL?",
  "answer": "`NULL` в SQL — это **не значение**, а **отсутствие значения** (неопределённость).\n\nПоэтому он ведёт себя особым образом в выражениях, сравнениях и агрегациях.\n\n**Проверка на `NULL:`** `SELECT * FROM users WHERE email IS NULL;`\n\nнайдём записи без e-mail.\n\n**Проверка на \"не `NULL`\":** `SELECT * FROM users WHERE email IS NOT NULL;`\n\n**Замена `NULL` на дефолт:** `SELECT COALESCE(email, 'no-email') FROM users;`\n\nесли `email` \\= NULL, вернётся `'no-email'`.\n\n**1\\. Сравнения с `NULL.`**\n\nНельзя писать `= NULL` или `!= NULL`.\n\n`WHERE email = NULL   -- ❌ всегда вернёт UNKNOWN`\n\n`WHERE email IS NULL  -- ✅ правильный вариант`\n\n**2\\. Три-значная логика (TRUE / FALSE / UNKNOWN)**\n\nЕсли в выражении участвует `NULL`, результат часто становится `UNKNOWN`.\n\n`SELECT 1 WHERE NULL = 5;   -- ничего не вернёт`\n\n**3\\. `NULL` в агрегации**\n\n`COUNT(*)` считает все строки, даже с `NULL`.\n\n`COUNT(column)` игнорирует `NULL`.\n\n`COUNT(email)   -- посчитает только строки, где email NOT NULL`\n\n`COUNT(*)       -- посчитает все строки`\n\n**4\\. `NULL` в `JOIN`**\n\nПри `INNER JOIN` строки с `NULL` в ключах не соединяются.\n\nПри `LEFT JOIN` в результирующей таблице могут появиться `NULL`\\-ы в полях правой таблицы.\n\n**5\\. `NULL` в `GROUP BY.`** Все `NULL` значения попадают в **одну группу**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.4. Виды Join'ов?",
  "answer": "**1\\. INNER JOIN**\n\nВозвращает только строки, у которых есть совпадения в обеих таблицах.\n\n`SELECT u.id, u.name, o.id AS order_id`\n\n`FROM users u`\n\n`INNER JOIN orders o ON u.id = o.user_id;`\n\n**2\\. LEFT JOIN (LEFT OUTER JOIN)**\n\nБерёт все строки из левой таблицы \\+ совпадающие строки из правой. Если совпадений нет → `NULL`.\n\n`SELECT u.id, u.name, o.id AS order_id`\n\n`FROM users u`\n\n`LEFT JOIN orders o ON u.id = o.user_id;`\n\n**3\\. RIGHT JOIN (RIGHT OUTER JOIN)**\n\nАналог `LEFT JOIN`, но берёт все строки из **правой таблицы**.\n\nНа практике почти не используется, т.к. всегда можно переписать через `LEFT JOIN`.\n\n**4\\. FULL JOIN (FULL OUTER JOIN)**\n\nВозвращает все строки из обеих таблиц. Если совпадений нет, подставляются `NULL`.\n\n`SELECT u.id, o.id`\n\n`FROM users u`\n\n`FULL JOIN orders o ON u.id = o.user_id;`\n\n**5\\. CROSS JOIN**\n\nДекартово произведение: каждая строка первой таблицы × каждая строка второй.\n\n`SELECT u.id, p.id`\n\n`FROM users u`\n\n`CROSS JOIN products p;`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.5. Что лучше использовать join или подзапросы?",
  "answer": "**JOIN:**\n\n- Обычно **быстрее**, т.к. оптимизатор может использовать индексы и строить эффективные планы выполнения.\n\n- Удобен для **объединения данных** из нескольких таблиц.\n\n- Хорошо читается, если нужно просто соединить таблицы по ключам.\n\n**Подзапросы:**\n\n- Удобны для **агрегаций** и случаев, когда нужно сначала «посчитать что-то», а потом использовать это в фильтре.\n\n- Иногда делают SQL **более читаемым** (например, при фильтрации по сложным условиям).\n\n- Могут быть **медленнее**, если оптимизатор не умеет «разворачивать» подзапрос в `JOIN`.\n\nДля объединения таблиц **почти всегда лучше `JOIN`** (особенно при больших данных и наличии индексов).\n\nПодзапросы хороши, когда:\n\n- нужно сначала агрегировать / выбрать топ-N\n\n- нужна вложенная фильтрация\n\n- читаемость выше, чем с `JOIN`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.6. Чем WHERE отличается от HAVING?",
  "answer": "**WHERE**\n\n- Фильтрует **строки до группировки и агрегации**.\n\n- Применяется к обычным столбцам.\n\n- Нельзя использовать агрегатные функции (`SUM`, `COUNT`, `AVG` и т. д.).\n\n**Пример:** выбрать только пользователей старше 18 лет:\n\n`SELECT *`\n\n`FROM users`\n\n`WHERE age \u003e= 18;`\n\n**HAVING**\n\n- Фильтрует **группы после группировки и агрегации**.\n\n- Применяется к результатам `GROUP BY` или агрегатам.\n\n- Часто идёт вместе с `GROUP BY`.\n\n**Пример:** выбрать только те страны, где больше 100 пользователей:\n\n`SELECT country, COUNT(*) AS user_count`\n\n`FROM users`\n\n`GROUP BY country`\n\n`HAVING COUNT(*) \u003e 100;`\n\n**Разница в одном примере**\n\nНайти всех пользователей старше 18 лет и показать только те города, где больше 10 таких пользователей:\n\n`SELECT city, COUNT(*) AS cnt`\n\n`FROM users`\n\n`WHERE age \u003e= 18        -- фильтруем строки до агрегации`\n\n`GROUP BY city`\n\n`HAVING COUNT(*) \u003e 10;  -- фильтруем уже сгруппированные данные`\n\n**Запомни простую формулу для собеса**\n\n- `WHERE` → фильтруем **строки** (до `GROUP BY`).\n\n- `HAVING` → фильтруем **группы** (после `GROUP BY`)."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.7. Что такое ORDER BY?",
  "answer": "`ORDER BY` используется для сортировки результата запроса по одному или нескольким столбцам. Сортировка может быть по возрастанию (`ASC`) или по убыванию (`DESC`). Это базовый инструмент для контроля порядка выдачи данных, особенно когда результаты нужно выводить пользователю или передавать в отчёт.\n\nПример:\n\n`SELECT *`\n\n`FROM employees`\n\n`ORDER BY last_name ASC;`"
}
