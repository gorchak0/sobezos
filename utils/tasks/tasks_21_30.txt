/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2.12. Что такое шардинг и репликация?",
  "answer": "**Шардинг (Sharding)**\nШардинг — это метод **горизонтального масштабирования**, когда данные делятся на независимые сегменты (**шарды**) и распределяются по разным серверам.\n- Каждый шард хранит только часть данных и обрабатывает только свою нагрузку.\n- Это позволяет системе обрабатывать большие объемы данных и писать/читать параллельно.\nМинусы: Трудности с глобальными запросами (`JOIN` или агрегации по всем шардам).\n**Репликация (Replication)**\nРепликация — это **создание копий данных** на нескольких серверах.\n- Обычно есть **primary** (мастер) и несколько **replica** (слейвов).\n- Primary принимает записи, реплики синхронно или асинхронно копируют изменения и обслуживают запросы на чтение.\nМинусы: Задержка репликации (особенно в асинхронных схемах).\n**Шардинг и репликация используют вместе**:\n- Шардинг — для горизонтального масштабирования (делим данные на сегменты).\n- Репликация — для отказоустойчивости и масштабирования чтения.\n**Пример:**\n- Пользователи делятся по регионам → каждый регион хранится в отдельном шарде.\n- В каждом шарде — одна основная база \\+ несколько реплик для чтения и резервирования."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2.13. Какие типы репликации существуют в PostgreSQL?",
  "answer": "1\\. Физическая (Streaming Replication, Master-Slave)\n- **Классический вариант:** есть один **primary** (мастер) и несколько **standby** (реплик).\n- Реплики получают WAL-записи (журнал транзакций) и применяют их для синхронизации.\n- Реплики доступны только для **чтения**.\n**Плюсы:** высокая производительность, простая настройка.\n**Минусы:** нагрузку на запись нельзя распределить.\n2\\. Логическая репликация (Logical Replication)\n- Позволяет реплицировать **не всю БД, а выбранные таблицы/колонки**.\n- Работает на уровне изменений данных (INSERT, UPDATE, DELETE).\n- Подходит для интеграции, аналитики, миграций и построения event-driven систем.\n**Плюсы:** гибкость (можно фильтровать данные).\n**Минусы:** медленнее физической, больше накладных расходов.\n3\\. Мастер-мастер репликация (Multi-Master, Bi-Directional Replication, BDR)\n- Несколько узлов работают как мастера: принимают и записи, и чтение.\n- Узлы синхронизируются между собой (обычно через логическую репликацию).\n- Используется для географически распределённых систем.\n**Плюсы:** распределение нагрузки на запись.\n**Минусы:** сложная настройка, конфликты при синхронизации.\n4\\. Каскадная репликация (Cascading Replication)\n- Реплика может сама быть источником для других реплик.\n- Полезно, когда у вас десятки узлов, и не хочется перегружать мастер.\n5\\. Асинхронная vs. Синхронная\n- **Асинхронная (по умолчанию):** мастер не ждёт подтверждения от реплик → быстрее, но возможна потеря данных при падении мастера.\n- **Синхронная:** мастер ждёт подтверждения от хотя бы одной реплики → данные гарантированно не теряются, но выше задержки записи."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2.14. По какому принципу могут данные шардироваться?",
  "answer": "**1\\. Горизонтальное шардирование (Horizontal Sharding)**\n- Данные делятся по **строкам**.\n- Каждая таблица в шарде содержит одинаковую схему, но разные подмножества строк.\nПример: пользователи из Европы в одном шарде, из Азии — в другом.\n❌ Минусы: сложность при глобальных запросах (JOIN по всем шардам).\n**2\\. Вертикальное шардирование (Vertical Sharding)**\n- Таблица разбивается по **столбцам**.\n- Каждый шард хранит только часть атрибутов объекта.\nПример: в одном шарде — «основные данные пользователя» (id, name, email), в другом — «редко используемые данные» (preferences, logs).\n❌ Минусы: чаще нужны JOIN между шардами.\n**3\\. Диапазонное шардирование (Range Sharding)**\n- Деление по диапазону значений ключа.\nПример: даты заказов → `2020–2021` в одном шарде, `2022–2023` в другом.\n❌ Минусы: при «горячем диапазоне» один шард может перегружаться.\n**4\\. Хэш-шардирование (Hash Sharding)**\n- Используется хэш-функция для ключа (например, `user_id % N`).\nПример: если у нас 4 шарда, пользователь с id=123 попадёт в шард `123 % 4 = 3`.\n❌ Минусы: сложно делать range-запросы.\n**5\\. По типу (Type Sharding)**\n- Данные делятся по сущностям или категориям.\nПример: одни шарды для пользователей, другие — для продуктов, третьи — для логов.\n❌ Минусы: возможны перекосы нагрузки (например, «шард пользователей» перегружен).\n**6\\. Смешанное (Composite Sharding)**\n- Комбинация методов."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.1. Что такое SQL?",
  "answer": "SQL (Structured Query Language) \\--- декларативный язык структурированных запросов. Это язык программирования, который используется для создания, изменения и управления данными в реляционных базах данных."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.2. Синтаксис языка SQL, Что такое DDL, DML, TCL, DCL?",
  "answer": "Вот основные элементы синтаксиса SQL и практические навыки, связанные с ним:\n1. Операторы DDL\n(Data Definition Language \\- Язык Определения Данных):\n- CREATE TABLE: Создание новой таблицы.\n- ALTER TABLE: Изменение структуры существующей таблицы.\n- DROP TABLE: Удаление таблицы.\n- CREATE DATABASE: Создание новой базы данных.\n- ALTER DATABASE: Изменение базы данных.\n- DROP DATABASE: Удаление базы данных.\n2. Операторы DML\n(Data Manipulation Language \\- Язык Манипуляции Данными)\n- SELECT: Извлечение данных из таблицы.\n- INSERT: Вставка новых данных в таблицу.\n- UPDATE: Обновление существующих данных в таблице.\n- DELETE: Удаление данных из таблицы.\n3. Операторы DCL\n(Data Control Language \\- Язык Контроля Доступа к Данным):\n- GRANT: Предоставление прав доступа к данным другим пользователям\nили ролям.\n- REVOKE: Отзыв прав доступа к данным.\n4. Операторы TCL\n(Transaction Control Language \\- Язык Управления Транзакциями):\n- COMMIT: Завершение текущей транзакции и сохранение изменений в базе данных.\n- ROLLBACK: Откат текущей транзакции и отмена всех изменений.\n- SAVEPOINT: Создание точки сохранения внутри транзакции.\n5. Операторы фильтрации и сортировки:\n- WHERE: Фильтрация результатов запроса на основе условий.\n- ORDER BY: Сортировка результатов по одному или нескольким столбцам.\n- GROUP BY: Группировка данных по одному или нескольким столбцам.\n- HAVING: Фильтрация результатов группировки.\n6. Функции агрегации:\n- COUNT(): Подсчет количества строк.\n- SUM(): Суммирование числовых значений.\n- AVG(): Вычисление среднего значения.\n- MAX(): Поиск максимального значения.\n- MIN(): Поиск минимального значения.\n7. Соединения таблиц:\n- INNER JOIN: Внутреннее соединение двух таблиц на основе совпадающих значений.\n- LEFT JOIN: Левое соединение, включая все строки из первой таблицы и соответствующие строки из второй таблицы.\n- RIGHT JOIN: Правое соединение, включая все строки из второй таблицы и соответствующие строки из первой таблицы.\n- FULL OUTER JOIN: Полное внешнее соединение, включая все строки из обеих таблиц.\n8. Подзапросы:\n- Вложенные SELECT запросы, используемые для выполнения запросов внутри других запросов."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.3. Нюансы работы с NULL в SQL. Как проверить поле на NULL?",
  "answer": "`NULL` в SQL — это **не значение**, а **отсутствие значения** (неопределённость).\nПоэтому он ведёт себя особым образом в выражениях, сравнениях и агрегациях.\n**Проверка на `NULL:`** `SELECT * FROM users WHERE email IS NULL;`\nнайдём записи без e-mail.\n**Проверка на \"не `NULL`\":** `SELECT * FROM users WHERE email IS NOT NULL;`\n**Замена `NULL` на дефолт:** `SELECT COALESCE(email, 'no-email') FROM users;`\nесли `email` \\= NULL, вернётся `'no-email'`.\n**1\\. Сравнения с `NULL.`**\nНельзя писать `= NULL` или `!= NULL`.\n`WHERE email = NULL   -- ❌ всегда вернёт UNKNOWN`\n`WHERE email IS NULL  -- ✅ правильный вариант`\n**2\\. Три-значная логика (TRUE / FALSE / UNKNOWN)**\nЕсли в выражении участвует `NULL`, результат часто становится `UNKNOWN`.\n`SELECT 1 WHERE NULL = 5;   -- ничего не вернёт`\n**3\\. `NULL` в агрегации**\n`COUNT(*)` считает все строки, даже с `NULL`.\n`COUNT(column)` игнорирует `NULL`.\n`COUNT(email)   -- посчитает только строки, где email NOT NULL`\n`COUNT(*)       -- посчитает все строки`\n**4\\. `NULL` в `JOIN`**\nПри `INNER JOIN` строки с `NULL` в ключах не соединяются.\nПри `LEFT JOIN` в результирующей таблице могут появиться `NULL`\\-ы в полях правой таблицы.\n**5\\. `NULL` в `GROUP BY.`** Все `NULL` значения попадают в **одну группу**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.4. Виды Join'ов?",
  "answer": "**1\\. INNER JOIN**\nВозвращает только строки, у которых есть совпадения в обеих таблицах.\n`SELECT u.id, u.name, o.id AS order_id`\n`FROM users u`\n`INNER JOIN orders o ON u.id = o.user_id;`\n**2\\. LEFT JOIN (LEFT OUTER JOIN)**\nБерёт все строки из левой таблицы \\+ совпадающие строки из правой. Если совпадений нет → `NULL`.\n`SELECT u.id, u.name, o.id AS order_id`\n`FROM users u`\n`LEFT JOIN orders o ON u.id = o.user_id;`\n**3\\. RIGHT JOIN (RIGHT OUTER JOIN)**\nАналог `LEFT JOIN`, но берёт все строки из **правой таблицы**.\nНа практике почти не используется, т.к. всегда можно переписать через `LEFT JOIN`.\n**4\\. FULL JOIN (FULL OUTER JOIN)**\nВозвращает все строки из обеих таблиц. Если совпадений нет, подставляются `NULL`.\n`SELECT u.id, o.id`\n`FROM users u`\n`FULL JOIN orders o ON u.id = o.user_id;`\n**5\\. CROSS JOIN**\nДекартово произведение: каждая строка первой таблицы × каждая строка второй.\n`SELECT u.id, p.id`\n`FROM users u`\n`CROSS JOIN products p;`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.5. Что лучше использовать join или подзапросы?",
  "answer": "**JOIN:**\n- Обычно **быстрее**, т.к. оптимизатор может использовать индексы и строить эффективные планы выполнения.\n- Удобен для **объединения данных** из нескольких таблиц.\n- Хорошо читается, если нужно просто соединить таблицы по ключам.\n**Подзапросы:**\n- Удобны для **агрегаций** и случаев, когда нужно сначала «посчитать что-то», а потом использовать это в фильтре.\n- Иногда делают SQL **более читаемым** (например, при фильтрации по сложным условиям).\n- Могут быть **медленнее**, если оптимизатор не умеет «разворачивать» подзапрос в `JOIN`.\nДля объединения таблиц **почти всегда лучше `JOIN`** (особенно при больших данных и наличии индексов).\nПодзапросы хороши, когда:\n- нужно сначала агрегировать / выбрать топ-N\n- нужна вложенная фильтрация\n- читаемость выше, чем с `JOIN`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.6. Чем WHERE отличается от HAVING?",
  "answer": "**WHERE**\n- Фильтрует **строки до группировки и агрегации**.\n- Применяется к обычным столбцам.\n- Нельзя использовать агрегатные функции (`SUM`, `COUNT`, `AVG` и т. д.).\n**Пример:** выбрать только пользователей старше 18 лет:\n`SELECT *`\n`FROM users`\n`WHERE age \u003e= 18;`\n**HAVING**\n- Фильтрует **группы после группировки и агрегации**.\n- Применяется к результатам `GROUP BY` или агрегатам.\n- Часто идёт вместе с `GROUP BY`.\n**Пример:** выбрать только те страны, где больше 100 пользователей:\n`SELECT country, COUNT(*) AS user_count`\n`FROM users`\n`GROUP BY country`\n`HAVING COUNT(*) \u003e 100;`\n**Разница в одном примере**\nНайти всех пользователей старше 18 лет и показать только те города, где больше 10 таких пользователей:\n`SELECT city, COUNT(*) AS cnt`\n`FROM users`\n`WHERE age \u003e= 18        -- фильтруем строки до агрегации`\n`GROUP BY city`\n`HAVING COUNT(*) \u003e 10;  -- фильтруем уже сгруппированные данные`\n**Запомни простую формулу для собеса**\n- `WHERE` → фильтруем **строки** (до `GROUP BY`).\n- `HAVING` → фильтруем **группы** (после `GROUP BY`)."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.7. Что такое ORDER BY?",
  "answer": "`ORDER BY` используется для сортировки результата запроса по одному или нескольким столбцам. Сортировка может быть по возрастанию (`ASC`) или по убыванию (`DESC`). Это базовый инструмент для контроля порядка выдачи данных, особенно когда результаты нужно выводить пользователю или передавать в отчёт.\nПример:\n`SELECT *`\n`FROM employees`\n`ORDER BY last_name ASC;`"
}
