/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "Nats",
  "answer": "NATS — это высокопроизводительная, легковесная и open-source система сообщений, предназначенная для обмена сообщениями между компонентами распределённых систем. Она идеально подходит для **микросервисной архитектуры, IoT и событийно-ориентированных приложений**.\n\n**Основные преимущества NATS:**\n\n1. **Высокая производительность и низкая латентность**\n\n- Быстрая передача сообщений с минимальной задержкой.\n\n2. **Легковесность**\n\n- Низкое потребление ресурсов и небольшой размер, подходит для ограниченных сред.\n\n3. **Простота использования**\n\n- Лёгкая интеграция с любыми языками и фреймворками.\n\n4. **Масштабируемость и кластеризация**\n\n- Поддержка горизонтального масштабирования и кластеризации для высоконагруженных приложений.\n\n5. **Отказоустойчивость**\n\n- Механизмы для обеспечения надежной доставки сообщений.\n\n6. **Безопасность**\n\n- Поддержка авторизации и шифрования сообщений.\n\n**Основные сценарии использования NATS:**\n\n1. **Микросервисы**\n\n- Связь и обмен сообщениями между сервисами через Pub/Sub и request-reply модели.\n\n2. **Интернет вещей (IoT)**\n\n- Передача данных между устройствами и центральными серверами, управление сенсорами и устройствами.\n\n3. **Событийно-ориентированные приложения**\n\n- Реализация реактивных систем, потоковая обработка событий в реальном времени.\n\n4. **Очереди сообщений**\n\n- Асинхронная обработка задач и балансировка нагрузки между обработчиками.\n\n5. **Финансовые системы и аналитика**\n\n- Передача данных в реальном времени для биржевых приложений, систем мониторинга и аналитики.\n\n6. **Мониторинг и логирование**\n\n- Сбор метрик и событий в распределённых приложениях.\n\n**Примеры использования:**\n\n- IoT и умные города — управление устройствами и сенсорами.\n\n- Финансовые системы — передача событий и данных в реальном времени.\n\n- Тестовые среды и разработка распределённых приложений.\n\n**Вывод:**\n\nNATS — это **мощный инструмент для построения распределенных, масштабируемых и отказоустойчивых систем**, где требуется быстрая и надёжная передача сообщений между компонентами."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "1\\. Replica Set (Репликационный набор)",
  "answer": "- **Определение:** группа узлов MongoDB, которые поддерживают одинаковую копию данных.\n\n- Минимальная конфигурация: **Primary \\+ Secondary \\+ Arbiter (по желанию)**.\n\n- Рекомендуется иметь **нечетное число участников**, чтобы исключить \"split-brain\" (ситуацию, когда нет кворума).\n\n**Роли узлов:**\n\n- **Primary**\n\n- принимает все операции записи;\n\n- ведет **oplog** — журнал изменений;\n\n- отвечает на запросы чтения (по умолчанию).\n\n- **Secondary**\n\n- реплицирует данные с Primary;\n\n- можно использовать для чтения (в зависимости от **Read Preference**);\n\n- может стать новым Primary при failover.\n\n- **Arbiter**\n\n- не хранит данные, участвует только в голосовании;\n\n- нужен для обеспечения кворума в кластере с четным числом узлов."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2\\. Oplog (операционный журнал)",
  "answer": "- **Формат:** capped collection (`local.oplog.rs`), хранит последовательность операций в порядке их выполнения.\n\n- **Тип операций:** `insert`, `update`, `delete`, DDL (например, создание коллекции).\n\n- Secondary узлы читают oplog и **применяют операции в том же порядке**, чтобы синхронизироваться с Primary.\n\n- Объем oplog ограничен → старые записи затираются, что важно для disaster recovery."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3\\. Механизм репликации",
  "answer": "1. Клиент выполняет запись на **Primary**.\n\n2. Primary подтверждает запись и фиксирует её в **oplog**.\n\n3. Secondary через **oplog tailing** (stream-подписку) считывают новые операции.\n\n4. Secondary применяют изменения у себя в том же порядке.\n\nРепликация **асинхронная**, но можно добиться квазисинхронности через `Write Concern`."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4\\. Failover (автоматическое переключение)",
  "answer": "- Если Primary недоступен:\n\n1. Узлы Replica Set начинают процедуру **выборов (election)**.\n\n2. Каждый Secondary может предложить себя как нового Primary.\n\n3. Узлы голосуют, и тот, кто набирает **большинство голосов**, становится новым Primary.\n\n4. Клиентские драйверы автоматически перенаправляют запросы на нового Primary.\n\n⚡ Среднее время failover — несколько секунд (обычно 2–10 сек)."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "5\\. Write Concern (подтверждение записи)",
  "answer": "Управляет тем, сколько узлов должны подтвердить операцию:\n\n- `w:1` — только Primary;\n\n- `w:majority` — большинство узлов Replica Set;\n\n- `w:n` — конкретное число узлов.\n\nПримеры:\n\n`db.orders.insertOne({ item: \"book\" }, { writeConcern: { w: \"majority\", j: true } })`\n\n- `w: \"majority\"` — запись считается успешной только если большинство узлов её применили.\n\n- `j: true` — запись зафиксирована в журнале (journal), то есть переживет перезапуск."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "6\\. Read Preference (предпочтения чтения)",
  "answer": "Определяет, с какого узла читать:\n\n- `primary` (по умолчанию) — только с Primary.\n\n- `primaryPreferred` — сначала с Primary, но можно с Secondary, если Primary недоступен.\n\n- `secondary` — только с Secondary.\n\n- `secondaryPreferred` — в приоритете Secondary.\n\n- `nearest` — ближайший по сетевой задержке узел.\n\n⚠️ Важно: чтение с Secondary может возвращать \"устаревшие\" данные из\\-за **replication lag**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "7\\. Replication Lag (задержка репликации)",
  "answer": "- Время между записью на Primary и применением её на Secondary.\n\n- Причины:\n\n- слабое «железо» у Secondary;\n\n- перегрузка по запросам;\n\n- большие write-нагрузки.\n\n- Последствия:\n\n- при чтении с Secondary можно получить устаревшие данные;\n\n- при failover данные могут потеряться, если новый Primary не успел догнать старый."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "8\\. Arbiter (Арбитр)",
  "answer": "- Узел без данных, только для голосования.\n\n- Используется для кворума, но снижает отказоустойчивость (так как нет дополнительных копий данных)\n\n- В проде стараются заменять Arbiter на полноценный Secondary."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "9\\. Связь с Шардированием",
  "answer": "- В MongoDB шардирование и репликация **работают вместе**:\n\n- **Шардирование** — распределяет данные по множеству шардов (горизонтальное масштабирование).\n\n- Каждый **шард \\= Replica Set**, чтобы внутри шарда были отказоустойчивость и консистентность."
}
