/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "Nats",
  "answer": "NATS — это высокопроизводительная, легковесная и open-source система сообщений, предназначенная для обмена сообщениями между компонентами распределённых систем. Она идеально подходит для **микросервисной архитектуры, IoT и событийно-ориентированных приложений**.\n**Основные преимущества NATS:**\n1. **Высокая производительность и низкая латентность**\n- Быстрая передача сообщений с минимальной задержкой.\n2. **Легковесность**\n- Низкое потребление ресурсов и небольшой размер, подходит для ограниченных сред.\n3. **Простота использования**\n- Лёгкая интеграция с любыми языками и фреймворками.\n4. **Масштабируемость и кластеризация**\n- Поддержка горизонтального масштабирования и кластеризации для высоконагруженных приложений.\n5. **Отказоустойчивость**\n- Механизмы для обеспечения надежной доставки сообщений.\n6. **Безопасность**\n- Поддержка авторизации и шифрования сообщений.\n**Основные сценарии использования NATS:**\n1. **Микросервисы**\n- Связь и обмен сообщениями между сервисами через Pub/Sub и request-reply модели.\n2. **Интернет вещей (IoT)**\n- Передача данных между устройствами и центральными серверами, управление сенсорами и устройствами.\n3. **Событийно-ориентированные приложения**\n- Реализация реактивных систем, потоковая обработка событий в реальном времени.\n4. **Очереди сообщений**\n- Асинхронная обработка задач и балансировка нагрузки между обработчиками.\n5. **Финансовые системы и аналитика**\n- Передача данных в реальном времени для биржевых приложений, систем мониторинга и аналитики.\n6. **Мониторинг и логирование**\n- Сбор метрик и событий в распределённых приложениях.\n**Примеры использования:**\n- IoT и умные города — управление устройствами и сенсорами.\n- Финансовые системы — передача событий и данных в реальном времени.\n- Тестовые среды и разработка распределённых приложений.\n**Вывод:**\nNATS — это **мощный инструмент для построения распределенных, масштабируемых и отказоустойчивых систем**, где требуется быстрая и надёжная передача сообщений между компонентами."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "1\\. Replica Set (Репликационный набор)",
  "answer": "- **Определение:** группа узлов MongoDB, которые поддерживают одинаковую копию данных.\n- Минимальная конфигурация: **Primary \\+ Secondary \\+ Arbiter (по желанию)**.\n- Рекомендуется иметь **нечетное число участников**, чтобы исключить \"split-brain\" (ситуацию, когда нет кворума).\n**Роли узлов:**\n- **Primary**\n- принимает все операции записи;\n- ведет **oplog** — журнал изменений;\n- отвечает на запросы чтения (по умолчанию).\n- **Secondary**\n- реплицирует данные с Primary;\n- можно использовать для чтения (в зависимости от **Read Preference**);\n- может стать новым Primary при failover.\n- **Arbiter**\n- не хранит данные, участвует только в голосовании;\n- нужен для обеспечения кворума в кластере с четным числом узлов."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "2\\. Oplog (операционный журнал)",
  "answer": "- **Формат:** capped collection (`local.oplog.rs`), хранит последовательность операций в порядке их выполнения.\n- **Тип операций:** `insert`, `update`, `delete`, DDL (например, создание коллекции).\n- Secondary узлы читают oplog и **применяют операции в том же порядке**, чтобы синхронизироваться с Primary.\n- Объем oplog ограничен → старые записи затираются, что важно для disaster recovery."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3\\. Механизм репликации",
  "answer": "1. Клиент выполняет запись на **Primary**.\n2. Primary подтверждает запись и фиксирует её в **oplog**.\n3. Secondary через **oplog tailing** (stream-подписку) считывают новые операции.\n4. Secondary применяют изменения у себя в том же порядке.\nРепликация **асинхронная**, но можно добиться квазисинхронности через `Write Concern`."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4\\. Failover (автоматическое переключение)",
  "answer": "- Если Primary недоступен:\n1. Узлы Replica Set начинают процедуру **выборов (election)**.\n2. Каждый Secondary может предложить себя как нового Primary.\n3. Узлы голосуют, и тот, кто набирает **большинство голосов**, становится новым Primary.\n4. Клиентские драйверы автоматически перенаправляют запросы на нового Primary.\n⚡ Среднее время failover — несколько секунд (обычно 2–10 сек)."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "5\\. Write Concern (подтверждение записи)",
  "answer": "Управляет тем, сколько узлов должны подтвердить операцию:\n- `w:1` — только Primary;\n- `w:majority` — большинство узлов Replica Set;\n- `w:n` — конкретное число узлов.\nПримеры:\n`db.orders.insertOne({ item: \"book\" }, { writeConcern: { w: \"majority\", j: true } })`\n- `w: \"majority\"` — запись считается успешной только если большинство узлов её применили.\n- `j: true` — запись зафиксирована в журнале (journal), то есть переживет перезапуск."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "6\\. Read Preference (предпочтения чтения)",
  "answer": "Определяет, с какого узла читать:\n- `primary` (по умолчанию) — только с Primary.\n- `primaryPreferred` — сначала с Primary, но можно с Secondary, если Primary недоступен.\n- `secondary` — только с Secondary.\n- `secondaryPreferred` — в приоритете Secondary.\n- `nearest` — ближайший по сетевой задержке узел.\n⚠️ Важно: чтение с Secondary может возвращать \"устаревшие\" данные из\\-за **replication lag**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "7\\. Replication Lag (задержка репликации)",
  "answer": "- Время между записью на Primary и применением её на Secondary.\n- Причины:\n- слабое «железо» у Secondary;\n- перегрузка по запросам;\n- большие write-нагрузки.\n- Последствия:\n- при чтении с Secondary можно получить устаревшие данные;\n- при failover данные могут потеряться, если новый Primary не успел догнать старый."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "8\\. Arbiter (Арбитр)",
  "answer": "- Узел без данных, только для голосования.\n- Используется для кворума, но снижает отказоустойчивость (так как нет дополнительных копий данных)\n- В проде стараются заменять Arbiter на полноценный Secondary."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "9\\. Связь с Шардированием",
  "answer": "- В MongoDB шардирование и репликация **работают вместе**:\n- **Шардирование** — распределяет данные по множеству шардов (горизонтальное масштабирование).\n- Каждый **шард \\= Replica Set**, чтобы внутри шарда были отказоустойчивость и консистентность."
}
