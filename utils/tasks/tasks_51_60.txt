/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.3. Пример работы покрывающего индекса",
  "answer": "`![][image3]![][image4]`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.4. Какие структуры данных используются в индексах PostgreSQL?",
  "answer": "В PostgreSQL индексы — это структуры данных, которые **ускоряют поиск и фильтрацию данных в таблицах**. Они не хранят сами данные, а содержат ссылки на строки таблицы, организованные так, чтобы можно было быстро найти нужные записи. PostgreSQL поддерживает несколько типов структур для индексов, каждая подходит для определенных сценариев:\n\n**1\\. B-дерево (B-tree)**\n\n- Самый распространённый тип индекса в PostgreSQL.\n\n- Отлично подходит для **сортированных данных и диапазонных запросов** (`\u003c`, `\u003e`, `BETWEEN`, `ORDER BY`).\n\n- Подходит для обычных уникальных и неуникальных индексов.\n\n**2\\. Составной индекс (Composite index)**\n\n- Создаётся на **нескольких столбцах** таблицы.\n\n- Помогает ускорять запросы с фильтрацией или сортировкой по нескольким колонкам одновременно.\n\n- Важно помнить порядок колонок — он влияет на эффективность.\n\n**3\\. GIN (Generalized Inverted Index)**\n\n- Эффективен для **поиска по массивам, JSONB, hstore и полнотексту**.\n\n- Подходит для случаев, когда нужно искать по множеству значений внутри одного поля.\n\n- Используется в `@\u003e`, `?`, `@@` и других операциях поиска.\n\n**4\\. GiST (Generalized Search Tree)**\n\n- Универсальная структура, которую можно настраивать под **геоданные, полнотекстовый поиск и сложные пользовательские типы**.\n\n- Используется для запросов, где простые B-tree индексы неэффективны, например, пространственные данные (`PostGIS`) или R-tree–подобные поиски.\n\n**5\\. Hash-индексы**\n\n- Используются для поиска по **точному совпадению значения**.\n\n- Работают быстро при точных фильтрах (`=`), но в PostgreSQL их использование ограничено: они не поддерживают сортировку и диапазонные запросы.\n\n##\n\n##"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.5. Часто задаваемый вопрос по индексам PostgreSQL, различие между B-деревом и хеш-таблицей",
  "answer": "B-дерево используется для определения записей в сравнении больше / меньше / равно, а хеш-таблица используется для определения записей в сравнении равно. То есть B-дерево может использоваться для поиска по диапазону, а хеш-таблица \\- нет."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.6. Как снизить нагрузку с помощью индексов?",
  "answer": "**1\\. Ускорение поиска**\n\n- Индексы позволяют быстро находить строки по условиям `WHERE`, `JOIN` и `ORDER BY`.\n\n- Создание индексов на часто используемых колонках существенно сокращает время выполнения запросов.\n\n**2\\. Снижение нагрузки при фильтрации**\n\n- С индексом СУБД обрабатывает только релевантные строки, уменьшая нагрузку на CPU и память.\n\n- Особенно эффективно для больших таблиц.\n\n**3\\. Оптимизация соединений (JOIN)**\n\n- Индексы на колонках, участвующих в `JOIN`, ускоряют поиск совпадений между таблицами.\n\n- Без индекса соединение требует полного сканирования таблиц → дорого по ресурсам.\n\n**4\\. Сортировка и группировка (ORDER BY / GROUP BY)**\n\n- Индексы позволяют СУБД быстрее сортировать и группировать данные, используя уже упорядоченную структуру.\n\n**5\\. Поиск по первичному ключу (PRIMARY KEY)**\n\n- Первичный ключ автоматически индексируется.\n\n- Поиск по уникальному идентификатору становится мгновенным, что снижает нагрузку на систему.\n\nИндексы ускоряют чтение, но **замедляют вставку и обновление**, т.к. их нужно поддерживать.\n\nПодбор правильных типов данных (например, `INT` вместо `VARCHAR` для чисел) повышает эффективность индекса и поиска."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.7. Почему нельзя повесить индекс на каждый столбец?",
  "answer": "**1\\. Потребление ресурсов**\n\n- Каждый индекс занимает место на диске и частично в памяти.\n\n- Если индексировать все столбцы, таблица будет весить гораздо больше, что увеличивает нагрузку на I/O и кеширование.\n\n**2\\. Замедление операций записи**\n\n- При вставке, обновлении или удалении строк нужно поддерживать все индексы в актуальном состоянии.\n\n- Для B-дерева (B-tree), который PostgreSQL использует по умолчанию, перестройка индекса занимает `O(log n)` времени для каждой записи.\n\n- Чем больше индексов, тем выше стоимость каждой записи: вставка, обновление или удаление становится медленнее.\n\n**3\\. Сложность поддержки**\n\n- Множество индексов усложняет администрирование: пересоздание, VACUUM, анализ статистики.\n\n- Растёт риск избыточных или дублирующих индексов, которые фактически не ускоряют запросы.\n\nИндексы — это **баланс между чтением и записью**. Нужно индексировать **только те столбцы, по которым реально часто ищут, сортируют или делают JOIN**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.8. Селективность в составном индексе",
  "answer": "**Селективность** — это параметр индекса, показывает, насколько уникальны значения относительно размера таблицы.\n\nЧем выше селективность, тем меньше строк соответствует конкретному значению, и тем эффективнее индекс помогает фильтровать данные.\n\n**Составной индекс** — это индекс на нескольких столбцах, например `(A, B)`.\n\nСелективность составного индекса зависит от **селективности каждого столбца и их порядка**.\n\n- Столбец `A` — высокоселективный (много уникальных значений)\n\n- Столбец `B` — низкоселективный (мало уникальных значений).\n\nИндекс `(A, B)` будет **лучше**, чем `(B, A)`, потому что фильтрация сначала по `A` сразу отбрасывает большую часть строк, а затем уже применяется фильтр по `B`.\n\nПри создании составных индексов **ставьте сначала самые селективные столбцы**, если запросы фильтруют по нескольким колонкам."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.9. Отфильтрованные индексы",
  "answer": "Отфильтрованные индексы (или **partial indexes**) — это индексы, которые создаются не на всей таблице, а **только на подмножество строк**, удовлетворяющих заданному условию. Они полезны, когда нужно ускорить выборку определенного типа данных.\n\n**Основные преимущества**\n\n1. **Экономия места**\n\n- Индекс хранит только строки, соответствующие условию, поэтому занимает меньше дискового пространства.\n\n2. **Ускорение запросов**\n\n- Меньший индекс \\= меньше страниц для сканирования. Запросы, которые используют этот индекс, выполняются быстрее.\n\n3. **Меньшее обслуживание**\n\n- Перестроение и обновление индекса занимает меньше времени, так как индекс содержит только часть данных.\n\n**🔹 Пример в PostgreSQL**\n\n`CREATE INDEX idx_filtered_example`\n\n`ON your_table (column_name)`\n\n`WHERE condition;`\n\n- `idx_filtered_example` — имя индекса.\n\n- `your_table` — таблица, на которой создаем индекс.\n\n- `column_name` — колонка для индексации.\n\n- `condition` — фильтр, определяющий, какие строки войдут в индекс.\n\n**🔹 Когда использовать**\n\n- Когда **подмножество данных** часто запрашивается, а остальные строки редко.\n\n- Когда важно **сэкономить место** и **снизить нагрузку на обновления**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.10. Добавление неиспользуемых полей в индекс",
  "answer": "Добавление полей в индекс, которые фактически **не используются в запросах**, — это плохая практика. Такой подход не даёт выгоды, но создаёт ряд проблем для производительности базы данных.\n\nПочему это плохо\n\n1. **Увеличение размера индекса**\n\n- Каждое поле добавляет данные в индекс.\n\n- Неиспользуемые поля только занимают место на диске и в памяти, без пользы для ускорения запросов.\n\n2. **Замедление операций записи**\n\n- При вставке, обновлении или удалении PostgreSQL нужно поддерживать все индексы в актуальном состоянии.\n\n- Чем больше индекс (особенно с лишними полями), тем дороже эти операции по CPU и I/O.\n\nРекомендации\n\n- Индексировать **только те столбцы**, которые реально используются в запросах.\n\n- Использовать инструменты анализа запросов:\n\n- `EXPLAIN` / `EXPLAIN ANALYZE` для оценки плана выполнения.\n\n- `pg_stat_statements` и `pg_stat_activity` для мониторинга нагрузки и поиска горячих точек.\n\n- Проводить регулярный аудит индексов, удаляя или пересоздавая лишние.\n\n#\n\n-"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "7.24. Если у нас у колонки три уникальных значения, есть ли смысл делать индекс по этому полю? (селективность и кардинальность)",
  "answer": "В такой ситуации индекс почти всегда бесполезен. Причина в низкой **кардинальности** (всего три уникальных значения) и, соответственно, слабой **селективности**. Индексы эффективны, когда они позволяют быстро отобрать небольшой поднабор строк. Но если, скажем, каждое значение встречается в десятках тысяч строк, СУБД проще сделать full table scan, чем ходить по индексу и потом вытаскивать все эти записи.\n\nЕсть редкие случаи, когда индекс на колонке с низкой кардинальностью может пригодиться:\n\n- если эта колонка участвует в составном индексе с другими более селективными полями;\n\n- если запросы фильтруют именно по «редкому» значению, например `status = 'archived'`, которое реально встречается редко (1–2% строк).\n\nНо в общем случае индекс на поле с тремя значениями будет только занимать место и замедлять `INSERT/UPDATE/DELETE`.\n\nНа практике я обычно смотрю на статистику использования запросов и на распределение значений. Если селективность низкая — индекс не создаю."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "7.25. Как примерно прикинуть количество строк в таблице?",
  "answer": "1. **Системные метаданные:** большинство СУБД хранят статистику по таблицам. В PostgreSQL, например, можно посмотреть в `pg_class.reltuples` или во вьюхах вроде `pg_stat_user_tables`. Это даст приближённое число строк.\n\n2. **Статистика планировщика:** Postgres поддерживает функции вроде `pg_stat_get_live_tuples`, которые возвращают оценку количества «живых» строк (т. е. без удалённых).\n\n3. **Через индексы:** можно посмотреть статистику по индексам, если они покрывают все строки, но это будет тоже оценка.\n\n4. **EXPLAIN:** иногда используют `EXPLAIN` для запроса `SELECT * FROM table;` — планировщик покажет предполагаемое количество строк, основываясь на своей статистике.\n\n5. **Грубый расчёт по размеру:** берём размер таблицы на диске (например, через `pg_relation_size`) и делим на средний размер строки. Это очень грубая оценка, но иногда полезна.\n\nНа практике: если нужна точная цифра — делаем `COUNT(*)`, но это дорого для больших таблиц. Если нужна прикидка для планирования запросов или анализа производительности — используем статистику СУБД."
}
