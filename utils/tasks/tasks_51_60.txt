/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.3. Пример работы покрывающего индекса",
  "answer": "`![][image3]![][image4]`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.4. Какие структуры данных используются в индексах PostgreSQL?",
  "answer": "В PostgreSQL индексы — это структуры данных, которые **ускоряют поиск и фильтрацию данных в таблицах**. Они не хранят сами данные, а содержат ссылки на строки таблицы, организованные так, чтобы можно было быстро найти нужные записи. PostgreSQL поддерживает несколько типов структур для индексов, каждая подходит для определенных сценариев:\n**1\\. B-дерево (B-tree)**\n- Самый распространённый тип индекса в PostgreSQL.\n- Отлично подходит для **сортированных данных и диапазонных запросов** (`\u003c`, `\u003e`, `BETWEEN`, `ORDER BY`).\n- Подходит для обычных уникальных и неуникальных индексов.\n**2\\. Составной индекс (Composite index)**\n- Создаётся на **нескольких столбцах** таблицы.\n- Помогает ускорять запросы с фильтрацией или сортировкой по нескольким колонкам одновременно.\n- Важно помнить порядок колонок — он влияет на эффективность.\n**3\\. GIN (Generalized Inverted Index)**\n- Эффективен для **поиска по массивам, JSONB, hstore и полнотексту**.\n- Подходит для случаев, когда нужно искать по множеству значений внутри одного поля.\n- Используется в `@\u003e`, `?`, `@@` и других операциях поиска.\n**4\\. GiST (Generalized Search Tree)**\n- Универсальная структура, которую можно настраивать под **геоданные, полнотекстовый поиск и сложные пользовательские типы**.\n- Используется для запросов, где простые B-tree индексы неэффективны, например, пространственные данные (`PostGIS`) или R-tree–подобные поиски.\n**5\\. Hash-индексы**\n- Используются для поиска по **точному совпадению значения**.\n- Работают быстро при точных фильтрах (`=`), но в PostgreSQL их использование ограничено: они не поддерживают сортировку и диапазонные запросы.\n##\n##"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.5. Часто задаваемый вопрос по индексам PostgreSQL, различие между B-деревом и хеш-таблицей",
  "answer": "B-дерево используется для определения записей в сравнении больше / меньше / равно, а хеш-таблица используется для определения записей в сравнении равно. То есть B-дерево может использоваться для поиска по диапазону, а хеш-таблица \\- нет."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.6. Как снизить нагрузку с помощью индексов?",
  "answer": "**1\\. Ускорение поиска**\n- Индексы позволяют быстро находить строки по условиям `WHERE`, `JOIN` и `ORDER BY`.\n- Создание индексов на часто используемых колонках существенно сокращает время выполнения запросов.\n**2\\. Снижение нагрузки при фильтрации**\n- С индексом СУБД обрабатывает только релевантные строки, уменьшая нагрузку на CPU и память.\n- Особенно эффективно для больших таблиц.\n**3\\. Оптимизация соединений (JOIN)**\n- Индексы на колонках, участвующих в `JOIN`, ускоряют поиск совпадений между таблицами.\n- Без индекса соединение требует полного сканирования таблиц → дорого по ресурсам.\n**4\\. Сортировка и группировка (ORDER BY / GROUP BY)**\n- Индексы позволяют СУБД быстрее сортировать и группировать данные, используя уже упорядоченную структуру.\n**5\\. Поиск по первичному ключу (PRIMARY KEY)**\n- Первичный ключ автоматически индексируется.\n- Поиск по уникальному идентификатору становится мгновенным, что снижает нагрузку на систему.\nИндексы ускоряют чтение, но **замедляют вставку и обновление**, т.к. их нужно поддерживать.\nПодбор правильных типов данных (например, `INT` вместо `VARCHAR` для чисел) повышает эффективность индекса и поиска."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.7. Почему нельзя повесить индекс на каждый столбец?",
  "answer": "**1\\. Потребление ресурсов**\n- Каждый индекс занимает место на диске и частично в памяти.\n- Если индексировать все столбцы, таблица будет весить гораздо больше, что увеличивает нагрузку на I/O и кеширование.\n**2\\. Замедление операций записи**\n- При вставке, обновлении или удалении строк нужно поддерживать все индексы в актуальном состоянии.\n- Для B-дерева (B-tree), который PostgreSQL использует по умолчанию, перестройка индекса занимает `O(log n)` времени для каждой записи.\n- Чем больше индексов, тем выше стоимость каждой записи: вставка, обновление или удаление становится медленнее.\n**3\\. Сложность поддержки**\n- Множество индексов усложняет администрирование: пересоздание, VACUUM, анализ статистики.\n- Растёт риск избыточных или дублирующих индексов, которые фактически не ускоряют запросы.\nИндексы — это **баланс между чтением и записью**. Нужно индексировать **только те столбцы, по которым реально часто ищут, сортируют или делают JOIN**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.8. Селективность в составном индексе",
  "answer": "**Селективность** — это параметр индекса, показывает, насколько уникальны значения относительно размера таблицы.\nЧем выше селективность, тем меньше строк соответствует конкретному значению, и тем эффективнее индекс помогает фильтровать данные.\n**Составной индекс** — это индекс на нескольких столбцах, например `(A, B)`.\nСелективность составного индекса зависит от **селективности каждого столбца и их порядка**.\n- Столбец `A` — высокоселективный (много уникальных значений)\n- Столбец `B` — низкоселективный (мало уникальных значений).\nИндекс `(A, B)` будет **лучше**, чем `(B, A)`, потому что фильтрация сначала по `A` сразу отбрасывает большую часть строк, а затем уже применяется фильтр по `B`.\nПри создании составных индексов **ставьте сначала самые селективные столбцы**, если запросы фильтруют по нескольким колонкам."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.9. Отфильтрованные индексы",
  "answer": "Отфильтрованные индексы (или **partial indexes**) — это индексы, которые создаются не на всей таблице, а **только на подмножество строк**, удовлетворяющих заданному условию. Они полезны, когда нужно ускорить выборку определенного типа данных.\n**Основные преимущества**\n1. **Экономия места**\n- Индекс хранит только строки, соответствующие условию, поэтому занимает меньше дискового пространства.\n2. **Ускорение запросов**\n- Меньший индекс \\= меньше страниц для сканирования. Запросы, которые используют этот индекс, выполняются быстрее.\n3. **Меньшее обслуживание**\n- Перестроение и обновление индекса занимает меньше времени, так как индекс содержит только часть данных.\n**🔹 Пример в PostgreSQL**\n`CREATE INDEX idx_filtered_example`\n`ON your_table (column_name)`\n`WHERE condition;`\n- `idx_filtered_example` — имя индекса.\n- `your_table` — таблица, на которой создаем индекс.\n- `column_name` — колонка для индексации.\n- `condition` — фильтр, определяющий, какие строки войдут в индекс.\n**🔹 Когда использовать**\n- Когда **подмножество данных** часто запрашивается, а остальные строки редко.\n- Когда важно **сэкономить место** и **снизить нагрузку на обновления**."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.10. Добавление неиспользуемых полей в индекс",
  "answer": "Добавление полей в индекс, которые фактически **не используются в запросах**, — это плохая практика. Такой подход не даёт выгоды, но создаёт ряд проблем для производительности базы данных.\nПочему это плохо\n1. **Увеличение размера индекса**\n- Каждое поле добавляет данные в индекс.\n- Неиспользуемые поля только занимают место на диске и в памяти, без пользы для ускорения запросов.\n2. **Замедление операций записи**\n- При вставке, обновлении или удалении PostgreSQL нужно поддерживать все индексы в актуальном состоянии.\n- Чем больше индекс (особенно с лишними полями), тем дороже эти операции по CPU и I/O.\nРекомендации\n- Индексировать **только те столбцы**, которые реально используются в запросах.\n- Использовать инструменты анализа запросов:\n- `EXPLAIN` / `EXPLAIN ANALYZE` для оценки плана выполнения.\n- `pg_stat_statements` и `pg_stat_activity` для мониторинга нагрузки и поиска горячих точек.\n- Проводить регулярный аудит индексов, удаляя или пересоздавая лишние.\n#\n-"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "7.24. Если у нас у колонки три уникальных значения, есть ли смысл делать индекс по этому полю? (селективность и кардинальность)",
  "answer": "В такой ситуации индекс почти всегда бесполезен. Причина в низкой **кардинальности** (всего три уникальных значения) и, соответственно, слабой **селективности**. Индексы эффективны, когда они позволяют быстро отобрать небольшой поднабор строк. Но если, скажем, каждое значение встречается в десятках тысяч строк, СУБД проще сделать full table scan, чем ходить по индексу и потом вытаскивать все эти записи.\nЕсть редкие случаи, когда индекс на колонке с низкой кардинальностью может пригодиться:\n- если эта колонка участвует в составном индексе с другими более селективными полями;\n- если запросы фильтруют именно по «редкому» значению, например `status = 'archived'`, которое реально встречается редко (1–2% строк).\nНо в общем случае индекс на поле с тремя значениями будет только занимать место и замедлять `INSERT/UPDATE/DELETE`.\nНа практике я обычно смотрю на статистику использования запросов и на распределение значений. Если селективность низкая — индекс не создаю."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "7.25. Как примерно прикинуть количество строк в таблице?",
  "answer": "1. **Системные метаданные:** большинство СУБД хранят статистику по таблицам. В PostgreSQL, например, можно посмотреть в `pg_class.reltuples` или во вьюхах вроде `pg_stat_user_tables`. Это даст приближённое число строк.\n2. **Статистика планировщика:** Postgres поддерживает функции вроде `pg_stat_get_live_tuples`, которые возвращают оценку количества «живых» строк (т. е. без удалённых).\n3. **Через индексы:** можно посмотреть статистику по индексам, если они покрывают все строки, но это будет тоже оценка.\n4. **EXPLAIN:** иногда используют `EXPLAIN` для запроса `SELECT * FROM table;` — планировщик покажет предполагаемое количество строк, основываясь на своей статистике.\n5. **Грубый расчёт по размеру:** берём размер таблицы на диске (например, через `pg_relation_size`) и делим на средний размер строки. Это очень грубая оценка, но иногда полезна.\nНа практике: если нужна точная цифра — делаем `COUNT(*)`, но это дорого для больших таблиц. Если нужна прикидка для планирования запросов или анализа производительности — используем статистику СУБД."
}
