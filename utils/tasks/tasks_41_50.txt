/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.19. Чем TRUNCATE отличается от DELETE?",
  "answer": "Основное различие в том, что `TRUNCATE` — это DDL-операция, а `DELETE` — DML.\n- **Скорость:** `TRUNCATE` работает быстрее, потому что не проходит по каждой строке и не пишет детальные записи в журнал транзакций. Он фактически пересоздаёт таблицу «с нуля» и сбрасывает автоинкрементные счётчики. `DELETE` идёт построчно, логгирует каждое удаление, поэтому на больших объёмах данных работает заметно медленнее.\n- **Транзакции и откат:** `DELETE` можно откатить, потому что каждая операция фиксируется в журнале. `TRUNCATE` обычно не логгируется построчно и откатить его нельзя (в зависимости от конкретной СУБД — в некоторых можно, если команда выполняется внутри транзакции, но в целом полагаться на это рискованно).\n- **Гибкость:** `DELETE` позволяет удалять строки выборочно через `WHERE`. `TRUNCATE` всегда убирает всё содержимое таблицы, никаких условий применить нельзя.\n- **Побочные эффекты:** `TRUNCATE` сбрасывает автоинкременты (например, `AUTO_INCREMENT` или `SERIAL`). `DELETE` счётчик не трогает.\nНа практике я выбираю `TRUNCATE`, если нужно быстро очистить таблицу полностью, например, при подготовке тестовых данных. Если же нужна частичная очистка или требуется контроль транзакций — однозначно `DELETE`"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.20. Что такое хранимые процедуры? Для чего они нужны?",
  "answer": "Хранимая процедура — это кусок SQL-кода, сохранённый в базе данных и выполняемый на стороне СУБД как единое целое. По сути, это «функция» внутри базы, которая может содержать бизнес-логику, работать с транзакциями и управлять данными без участия клиентского приложения.\nКлючевые моменты:\n- **Предварительная компиляция:** процедура компилируется один раз при создании, дальше выполняется быстрее, чем динамические запросы.\n- **Повторное использование:** можно вызвать из разных приложений или сервисов, логика централизована.\n- **Оптимизация сетевого трафика:** вместо отправки длинных SQL-запросов по сети, приложение вызывает процедуру, а база возвращает только результат.\n- **Безопасность:** можно ограничить доступ так, чтобы пользователи могли выполнять процедуру, но не имели прямого доступа к таблицам.\n- **Транзакции:** удобно инкапсулировать сложные операции в рамках одной транзакции.\n- **Снижение дублирования:** одна процедура заменяет одинаковую логику в разных частях приложения.\nПримеры применения: массовые вставки, агрегации, валидации данных, бизнес-операции уровня «создать заказ вместе с позициями».\nНа практике я отношусь к ним осторожно. В реляционных СУБД они удобны для инкапсуляции логики рядом с данными, но нужно учитывать минусы: сложнее версионировать, тестировать и переносить между СУБД. Поэтому я обычно держу бизнес-логику в приложении (например, на Go), а хранимые процедуры применяю точечно — там, где реально важна производительность"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.21. Что такое представления (VIEW)? Для чего они нужны?",
  "answer": "`VIEW` — это виртуальная таблица, которая формируется на основе SQL-запроса. Данные в ней физически не хранятся, они подтягиваются «на лету» из одной или нескольких таблиц при обращении к представлению.\nОсновные цели:\n- **Абстракция и упрощение:** скрыть сложные SQL-запросы за более простым интерфейсом, чтобы разработчики работали с «чистой» таблицей.\n- **Безопасность:** можно дать доступ к представлению с ограниченным набором колонок или строк вместо прямого доступа к таблицам.\n- **Повторное использование:** если где\\-то в системе много раз используется один и тот же сложный запрос, его можно вынести в `VIEW`, чтобы не дублировать код.\n- **Сокрытие сложности:** особенно полезно, когда запрос объединяет несколько таблиц или делает агрегаты.\n- **Виртуальная агрегация:** можно собрать данные из разных таблиц в одно место и использовать как источник для аналитики или отчётов.\nНа практике `VIEW` удобны, когда нужно раздать упрощённый или ограниченный доступ к данным другим командам или BI-системам. Но есть и подводные камни: сложные представления могут негативно влиять на производительность, особенно если в них много джойнов или агрегаций, а индексироваться напрямую они не могут. Поэтому я обычно использую их как средство для удобства и безопасности, но не как замену оптимизированных запросов или materialized view, если важна скорость."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.22. Что такое временные таблицы? Для чего они нужны?",
  "answer": "`VIEW` — это виртуальная таблица, которая формируется на основе SQL-запроса. Данные в ней физически не хранятся, они подтягиваются «на лету» из одной или нескольких таблиц при обращении к представлению.\nОсновные цели:\n- **Абстракция и упрощение:** скрыть сложные SQL-запросы за более простым интерфейсом, чтобы разработчики работали с «чистой» таблицей.\n- **Безопасность:** можно дать доступ к представлению с ограниченным набором колонок или строк вместо прямого доступа к таблицам.\n- **Повторное использование:** если где\\-то в системе много раз используется один и тот же сложный запрос, его можно вынести в `VIEW`, чтобы не дублировать код.\n- **Сокрытие сложности:** особенно полезно, когда запрос объединяет несколько таблиц или делает агрегаты.\n- **Виртуальная агрегация:** можно собрать данные из разных таблиц в одно место и использовать как источник для аналитики или отчётов.\nНа практике `VIEW` удобны, когда нужно раздать упрощённый или ограниченный доступ к данным другим командам или BI-системам. Но есть и подводные камни: сложные представления могут негативно влиять на производительность, особенно если в них много джойнов или агрегаций, а индексироваться напрямую они не могут. Поэтому я обычно использую их как средство для удобства и безопасности, но не как замену оптимизированных запросов или materialized view, если важна скорость."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.23. Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?",
  "answer": "Нормализация — это процесс структурирования данных в базе так, чтобы минимизировать избыточность и избежать аномалий при вставке, обновлении и удалении. Суть в том, чтобы данные были разложены по таблицам так, чтобы каждая таблица описывала одну сущность и хранила атомарные значения.\nТри базовые нормальные формы:\n- **1NF (первая нормальная форма):** таблица не содержит повторяющихся групп, и каждое поле хранит атомарное значение, без массивов или вложенных структур.\n- **2NF (вторая нормальная форма):** выполняется 1NF, плюс все неключевые атрибуты зависят от всего первичного ключа, а не от его части (актуально для составных ключей).\n- **3NF (третья нормальная форма):** выполняется 2NF, и отсутствуют транзитивные зависимости — то есть неключевые поля зависят только от ключа, а не друг от друга.\n**Денормализация** — это обратный процесс: объединяем данные в одну таблицу, даже если появляется избыточность, ради ускорения выборок. Чаще всего это делается в аналитических системах (OLAP), где критичнее скорость запросов, чем строгое соблюдение нормализации.\nНа практике:\n- Нормализация хорошо работает в OLTP-системах, где важны транзакции и целостность.\n- Денормализация полезна для отчётности, дашбордов, аналитики, когда запросы должны выполняться быстро.\n- Часто используют гибридный подход: храним данные в нормализованном виде, но для аналитики держим денормализованные витрины или materialized view."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.24. Что такое TIMESTAMP?",
  "answer": "`TIMESTAMP` — это тип данных для хранения даты и времени в базе. Обычно он включает год, месяц, день, часы, минуты, секунды и при необходимости дробные секунды с заданной точностью. По сути, это «временная метка», которая однозначно фиксирует момент времени.\nЕсть нюансы в зависимости от СУБД:\n- В некоторых базах (`Postgres`) `TIMESTAMP` может быть с часовым поясом (`TIMESTAMP WITH TIME ZONE`) или без него. Это важно, если система работает в распределённой среде.\n- В `MySQL` `TIMESTAMP` отличается от `DATETIME` тем, что хранится в формате UTC и при выборке конвертируется в локальный часовой пояс, тогда как `DATETIME` просто хранит «как есть».\n- Можно задавать точность до микросекунд.\nПрименение: логирование действий пользователей, хранение времени создания и изменения записей (`created_at`, `updated_at`), отслеживание событий, аналитика по временным промежуткам."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.25. Что такое автовакуум в постгресе?",
  "answer": "Автовакуум в PostgreSQL — это фоновый процесс, который автоматически поддерживает базу в рабочем состоянии: чистит «мусорные» записи и обновляет статистику.\nЗачем он нужен:\n- **Удаление «мертвых» строк:** в Postgres при `UPDATE` и `DELETE` данные физически не затираются, а помечаются как неактуальные. Автовакуум реально освобождает эти места.\n- **Освобождение пространства и предотвращение разрастания таблиц:** без вакуума таблицы только росли бы, даже при активных удалениях.\n- **Обновление статистики:** планировщик запросов использует её, чтобы строить оптимальные execution plan.\n- **Поддержание индексов:** автовакуум помогает избегать фрагментации и падения производительности.\nРаботает он в фоне и настраивается через параметры: можно регулировать частоту, пороги срабатывания, агрессивность. В высоконагруженных системах его поведение обычно тюнят под конкретные нагрузки, а иногда делают ручной `VACUUM` или `ANALYZE`, если нужно больше контроля.\nНа практике — автовакуум критически важен. Если его отключить или неправильно настроить, таблицы будут раздуваться, индексы деградировать, а производительность падать."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "3.26. Что такое vacuum в PostgreSQL и когда его нужно запускать?",
  "answer": "ВВ PostgreSQL `VACUUM` — это процесс, который очищает таблицы от «мертвых» строк (tuple), оставшихся после `UPDATE` и `DELETE`. В отличие от некоторых других СУБД, Postgres не перезаписывает данные «на месте» — при обновлении создаётся новая версия строки, а старая помечается как устаревшая. Пока не запущен `VACUUM`, эти строки занимают место и могут замедлять работу.\nЕсть несколько режимов:\n- **`VACUUM`** — освобождает место для повторного использования, но не уменьшает физический размер файла.\n- **`VACUUM FULL`** — переписывает таблицу целиком, реально сжимая её на диске, но это тяжёлая операция с блокировкой.\n- **`ANALYZE`** (часто используется вместе с `VACUUM`) — обновляет статистику для планировщика запросов.\nКогда запускать:\n- Обычно этим занимается **автовакуум** (AutoVacuum), который работает в фоне и автоматически чистит таблицы.\n- Но вручную `VACUUM` или `VACUUM FULL` запускают, если:\n- таблица сильно фрагментирована,\n- резко выросло количество `UPDATE`/`DELETE`,\n- нужно освободить дисковое пространство,"
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.1. Что такое индекс?",
  "answer": "Индекс — это структура данных, которая позволяет быстро находить данные в базе данных. Индексы используются для ускорения поиска данных в базе данных."
}
/taskadd
{
  "tags": [
    "мод_4_БД"
  ],
  "question": "4.2. Какие бывают индексы?",
  "answer": "Индексы бывают нескольких типов:\n- Кластерные (clustered) индексы. Кластерный индекс определяет порядок данных в таблице. Таблица может иметь только один кластерный индекс.\n- Некластерные (nonclustered) индексы. Некластерный индекс не определяет порядок данных в таблице. Таблица может иметь несколько некластерных индексов.\n- Покрывающие (covering) индексы. Покрывающий индекс содержит все данные, которые нужны для выполнения запроса. Покрывающие индексы позволяют избежать обращения к таблице."
}
